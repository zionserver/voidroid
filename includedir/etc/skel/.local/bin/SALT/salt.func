##########################################################################
## @file			salt.func
## @brief			The heart of SALT - all global functions
## @author			steadfasterX <steadfasterX -AT- gmail -DOT- com>
## @date                        2017-2018
## @copyright			LGPL v3
## @details                     SALT - [S]teadfasterX [A]ll-in-one [L]G [T]ool
##
## global functions for SALT
##
## include this with:
## source salt.func
#
##########################################################################
# doxygen copy templates:
#
# # @var 
# # @brief 
# # @showinitializer
# # @details 
#
# # @fn F_NAME()
# # @brief ..
# # @param 1 ..
# # @return ..
# # @exception ..
# # @details ..
#
##########################################################################
VARS="${0%/*}/salt.vars"
export HASHES="${0%/*}/salt.hashes"

source "$VARS"
[ $? -ne 0 ]&& echo "ERROR: including $VARS" && exit 3

source "$HASHES"
[ $? -ne 0 ]&& echo "ERROR: including $HASHES" && exit 3

# set CR arg
case $CRMODE in
    yes) export CROPT="--cr yes";;
    no) export CROPT="--cr no";;
    *) export CROPT="";;
esac
  
######################################################################################

# there is no need to change these as they get auto set by the VERSION var
if [ "${VERSION/*:}" == "TESTING" ];then
    export BRSALT=develop
    export BRKDZ=develop
    export BRLAF=g4-develop
    export BROSALT=master
    export BROKDZ=master
    export BROLAF=g4-stable
    export VCHK=https://raw.githubusercontent.com/steadfasterX/SALT/develop/salt.vars
else
    export BRSALT=master
    export BRKDZ=master
    export BRLAF=g4-stable
    export BROSALT=develop
    export BROKDZ=develop
    export BROLAF=g4-develop
    export VCHK=https://raw.githubusercontent.com/steadfasterX/SALT/master/salt.vars
fi

######################################################################################

# do not echo but write log entry
F_LOG(){
    # takes 1 argument
    # 1 => Message to log/echo (can handle \t and \n)
  
    echo -e "$(date '+%F %T'): $1" >> $LOG
}; export -f F_LOG

# echo output and save it in a log as well
F_ELOG(){
  # takes 1 argument
  # 1 => Message to log/echo (can handle \t and \n)
  
  echo -e "$(date '+%F %T'): $1" | tee -a $LOG

}; export -f F_ELOG
######################################################################################
F_LOG "CR setting: $CRMODE = $CROPT"
######################################################################################

# print a message
F_MSG(){ F_LOG "$FUNCNAME: started"
    # takes 2 arguments
    #   
    #  1 => box width
    #  2 => message to show
    # optional:
    #  3 => free args
    $FYAD --width=$1 --title="$YTITLE" --text "$2" $3
    RET=$?
    F_LOG "$2"
    F_LOG "$FUNCNAME: ended"
    echo $RET
}; export -f F_MSG

# print an error message
F_MSGE(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff
    
    $FYAD --width="$1" --title="$YTITLE - ERROR" --image="$SICONS/error.png" --text "ERROR:\n\n$2" $3 --button=Exit:0
    RES=$?
    F_LOG "ERROR: $2"
    F_LOG $RES
    echo $RES
}; export -f F_MSGE

# print an OK message
F_MSGOK(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff

    $FYAD --width="$1" --title="$YTITLE - SUCCESS" --image="$SICONS/ok_64x64.png" --text "\n$2" $3 --button=Close:0
    RES=$?
    F_LOG "$2"
    F_LOG $RES
    echo $RES
}; export -f F_MSGOK

# print a warning message
F_MSGW(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff

    $FYAD --width="$1" --title="$YTITLE - WARNING" --image="$SICONS/warning_64x64.png" --text "\n$2" $3 --button=Close:0
    RES=$?
    F_LOG "$2"
    F_LOG $RES
    echo $RES
}; export -f F_MSGW

# check errorcode + exit when not errorcode not as expected
F_ERR(){ F_LOG "$FUNCNAME: started"
  # takes 2-4 arguments
  #
  # mandantory:
  #   1 => the process initiating this function
  #   2 => the errorcode (usually $? in your call)
  # optional (4 requires at least an empty 3):
  #   3 => the message to show
  #   4 => the expected error code (if missing we expect 0)
  #   5 => yad code for F_MSGE (requires at least emtpy 3 and 4)
  CALLER=$1
  ERRCODE=$2
  MSG="$3"
  EXPECTED=$4
  YADSTUFF="$5"

  [ -z "$EXPECTED" ] && EXPECTED=0
  
  if [ -z "$CALLER" ]||[ -z "$ERRCODE" ];then
    F_ELOG "Required argument missing in $FUNCNAME!"
    F_EXIT $FUNCNAME 3
  fi
  if [ "$ERRCODE" != "$EXPECTED" ];then
    F_ELOG "ERROR: $ERRCODE occurred in $CALLER (expected $EXPECTED, got $ERRCODE)"
    [ ! -z "$MSG" ] && F_MSGE 800 "$MSG" "$YADSTUFF"
    F_EXIT "${CALLER}->${FUNCNAME}" 4
  else
    echo "OK: $CALLER"
  fi
}; export -f F_ERR

# exit properly
F_EXIT(){ F_LOG "$FUNCNAME: started"
  # takes 3 arguments
  # mandantory:
  #   1 => the function or reason who calls the exit function
  #   2 => the exitcode to be used
  #
  # optional:
  #   3 => type: cleaning lock file (full) or just close (when not set)
  EREASON=$1
  ECODE=$2
  ETYPE=$3
  
  F_ELOG "EXIT: $EREASON with code $ECODE"
  
  [ "$ETYPE" == "full" ] && rm -vf $LOCKFILE >> $LOG

  exit $ECODE
  F_LOG "$FUNCNAME: ended"
}; export -f F_EXIT

# detects the type of device storage
F_DETSTORAGE(){ F_LOG "$FUNCNAME: started"
   echo coming soon 
}; export -f F_DETSTORAGE

# get current phone data
F_GETINFO(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    $FYAD --title="$YTITLE - COLLECTING" --text "\n  Collecting device information..." --width=400 --timeout=25 --timeout-indicator=right --no-buttons &
    PBPP=$!
 
    IARB=$(F_CDARB)
    F_LOG "$FUNCNAME: ARB $IARB"
    USU=$(F_CKUSU)
    F_LOG "$FUNCNAME: USU $USU"
    ROMCOMP=$(F_ROMCOMP)
    F_LOG "$FUNCNAME: ROMCOMP $ROMCOMP"
    LAFVER=$(F_CHKLAFV)
    F_LOG "$FUNCNAME: LAFVER $LAFVER"

    echo "usu:${USU}" \
      && echo "romcomp:$ROMCOMP" \
      && echo "arb:${IARB}" \
      && echo "lafver:$LAFVER" \
      && $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!INFO GPRO \x08\x0b\0\0' --rawshell \
       | $PYTHONBIN $LAFPATH/scripts/parse-props.py - \
       | egrep "(device_sw_version|model_name|secure_device|laf_sw_version|device_factory_version|target_country|battery_level|imei|target_operator|serial)" | tr "\n" " " | tr -d "'" 
    F_LOG "$FUNCNAME: $(kill $PBPP)"
    F_LOG "$FUNCNAME: ended"
}; export -f F_GETINFO

# checks which ROM type is compatible with UsU on that device 
F_ROMCOMP(){ F_LOG "$FUNCNAME: started"
    # takes no arg

    DEVTMO=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list 2>&1 | grep -c carrier | tee -a $LOG)
    DEVEUR=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list 2>&1 | grep -c cust | tee -a $LOG)
    F_LOG "UsU compatibility: $DEVTMO (0=h815, 1=h811)"
    if [ "$DEVTMO" == "1" ];then
        echo "H811"
    elif [ "$DEVEUR" == "1" ];then
        echo "H815"
    else
        echo "unknown"
        F_LOG "UsU compatibility: cannot be detected! full GPT:"
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list 2>&1 >> $LOG
    fi
}; export -f F_ROMCOMP

# check the ARB of a KDZ file
F_KDZARB(){  F_LOG "$FUNCNAME: started with $@"
    # takes 2 args, returns ARB value found
    #
    # 1 => full path to kdz file
    # 2 => full extract path

    LGKDZ="$1"
    LGTARGET="$2"

    [ -z "$LGKDZ" -o ! -f "$LGKDZ" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGKDZ or file not found"
    [ -z "$LGTARGET" -o ! -d "$LGTARGET" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGTARGET or directory not found"

 
    F_LOG "$FUNCNAME: cleanup.."
    find "$LGTARGET" -type f -maxdepth 1 -name 'sbl*' -or -name 'xbl*' -exec rm -vf {}\\; >> $LOG 2>&1
    IRES=$($KDZMGR --batch --list -x "$LGKDZ" -d "$LGTARGET" 2>&1)
    ARBSLICE=$(echo "$IRES" |egrep "sbl|xbl"|head -n1|cut -d ":" -f 1)
    if [ -z "$ARBSLICE" ];then
        F_LOG "$FUNCNAME: no ARB or slice found >$ARBSLICE< .. skipping ARB detection .."
        echo "arb-detect-error"
    else
        F_LOG "$FUNCNAME: found ARB in slice >$ARBSLICE< .. extracting.."
        # extract ARB slice
        $KDZMGR --batch -x "$LGKDZ" -d "$LGTARGET" --slice "$ARBSLICE" >> $LOG 2>&1
        ARBFILE=$(find "${LGTARGET}/extracteddz" -type f -maxdepth 1 -name 'sbl*' -or -name 'xbl*')
        F_LOG "$FUNCNAME: ARBFILE = $ARBFILE"
        # get and print the ARB
        F_CKARB "$ARBFILE"
    fi
}; export -f F_KDZARB

# extract a KDZ
F_EXTRACTKDZ(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2-3 arguments
    #
    # required:
    #   1 => KDZ file name (full path)
    #   2 => Target directory
    # optional:
    #   3 => auto mode (e.g. for KDZ flashing)

    LGKDZ="$1"
    LGTARGET="$2"
    AUTOM="$3"

    [ -z "$LGKDZ" -o ! -f "$LGKDZ" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGKDZ or file not found"
    [ -z "$LGTARGET" -o ! -d "$LGTARGET" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGTARGET or directory not found"

    # ensure the target dir does not contain old image files
    [ "${LGTARGET}/extracteddz" ] && rm -rf "${LGTARGET}/extracteddz"
    [ "${LGTARGET}/extractekdz" ] && rm -rf "${LGTARGET}/extractedkdz"

    # open yad listener
    echo 0> /tmp/${FUNCNAME}_l
    tail -f /tmp/${FUNCNAME}_l | $FYAD --title="$YTITLE - COLLECT" --text="\n" --progress-text="Collecting KDZ information ..." --width=400 --progress --pulsate --no-buttons &
    echo 1 >> /tmp/${FUNCNAME}_l
    tail_pid=$!

    # grab the partition list
    IRES=$($KDZMGR --batch --list -x "$LGKDZ" -d "$LGTARGET" 2>&1)
    IRESDATA=$(echo -e "$IRES" |grep ":data" | sort -t : -k 2)
    IRESEMPTY=$(echo -e "$IRES" |grep ":empty" | sort -t : -k 2)

    # grab the ARB of the KDZ
    KDZARB=$(F_KDZARB "$LGKDZ" "$LGTARGET")

    # close yad listener
    kill $tail_pid
    rm /tmp/${FUNCNAME}_l

    # build the extract list based on the UsU state
    case "$LGUSU" in
        yes) IRESAUTO=$(echo -e "$IRESDATA" | egrep -iv "($AUTONOEXTRACTUSU)")
        ;;
        no|no_device_found) IRESAUTO=$(echo -e "$IRESDATA" | egrep -iv "($AUTONOEXTRACT)")
        ;;
        *) kill $tail_pid
           rm /tmp/${FUNCNAME}_l
           F_MSGE 500 "Unexpected LGUSU result ($LGUSU).. "
           F_EXIT "$FUNCNAME: Cannot determine UsU state" 3 
        ;; 
    esac
    F_LOG "collected data:\nUsU: $LGUSU\nIRESDATA:\n$IRESDATA\nIRESEMPTY:\n$IRESEMPTY\nIRESAUTO:\n$IRESAUTO"
    F_LOG "$FUNCNAME: $(kill $PBPP)"

    if [ x"$AUTOM" == "xauto" ];then
        CHOOSENP=$(echo -e "$IRESAUTO"| cut -d ":" -f 1-2)
    else
        IRESSORTED=$(echo -e "$IRESDATA\n$IRESEMPTY")
        BTNRET=66
        while [ "$BTNRET" -eq 77 -o "$BTNRET" -eq 66 ];do
            if [ "$BTNRET" == 66 ];then
              FCHOOSENP=$(for slice in $IRESSORTED;do if [ "${slice/*:/}" == "data" ];then echo -e "true:$slice"; else echo -e "false:$slice";fi | tr ':' '\n' ;done \
                        | $FYAD --height=800 --width=1000 --title="$YTITLE - EXTRACT" \
                        --text "\n  This KDZ has an <a href='https://bit.do/antirollg4'>ARB</a> of:  <span color='#ff0000' size='large'><b>$KDZARB</b></span>\n\n  Select partition(s) to EXTRACT:\n"\
                        --list --checklist \
                        --column="Selection":CHK \
                        --column="#" \
                        --column="Partition":TXT \
                        --column="Type" \
                        --listen --no-selection \
                        --button="Deselect All":77 \
                        --button=Extract:0 \
                        --button=Abort:3)
              BTNRET="${PIPESTATUS[0]}"
              CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2,3 | tr "|" ":"| tr "\n" " ")
              F_LOG "$FUNCNAME BTNRET: $BTNRET"
            else 
                if [ "$BTNRET" == 77 ];then
                  FCHOOSENP=$(for slice in $IRESSORTED;do if [ "${slice/*:/}" == "data" ];then echo -e "false:$slice"; else echo -e "false:$slice";fi | tr ':' '\n' ;done \
                            | $FYAD --height=800 --width=1000 --title="$YTITLE - EXTRACT" \
                            --text "\n  This KDZ has an <a href='https://bit.do/antirollg4'>ARB</a> of:  <span color='#ff0000' size='large'><b>$KDZARB</b></span>\n\n  Select partition(s) to EXTRACT:\n"\
                            --list --checklist \
                            --column="Selection":CHK \
                            --column="#" \
                            --column="Partition":TXT \
                            --column="Type" \
                            --listen --no-selection \
                            --button="Select All (with data)":66 \
                            --button=Extract:0 \
                            --button=Abort:3)
                  BTNRET="${PIPESTATUS[0]}"
                  CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2,3 | tr "|" ":"| tr "\n" " ")
                  F_LOG "$FUNCNAME BTNRET: $BTNRET"
                else
                  break
                fi
            fi
          done
    fi
    F_LOG "CHOOSENP: $CHOOSENP"

    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_MSGE 700 "No partition selected or aborted by user" && F_EXIT $FUNCNAME $CHCOUNT

    F_ELOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    # open yad listener
    echo 0> /tmp/e
    tail -f /tmp/e | $FYAD --title="$YTITLE - EXTRACT" --text="\n  <b>SALT is now extracting ...</b>\n  (just wait until this dialog closes)\n" --width=900 --progress --button='Close (WAIT until FINISHED)':0 --auto-close &
    tail_pid=$!

    MGRARGS=
    for slice in $CHOOSENP;do
        CNT=$((CNT+1))
        slicename=${slice/*:/}
        slicenum=${slice/:*/}
        echo "#extracting ${slicename} ..." >>/tmp/e
        [ $CNT -ne $CHCOUNT ] && MGRARGS="-D"
        $KDZMGR --batch -x "$LGKDZ" -d "$LGTARGET" --slice $slicenum --with-cache --with-userdata $MGRARGS >> $LOG 2>&1

        CNTPERC=$(($CNT * 100 / $CHCOUNT))
        echo $CNTPERC >>/tmp/e
        [ $CNT -eq $CHCOUNT ] && echo '# FINISHED!' >>/tmp/e && F_LOG "$FUNCNAME: Extract finished"
    done
    EXERR=$?

    # cleanup dz (but leave the dlls)
    rm -fv "$LGTARGET/extractedkdz/*.dz" >> $LOG

    # ensure regular users can work with the extracted stuff
    if [ "$LGTARGET" != "/tmp" ] && [ "$LGTARGET" != "/" ];then
        chown -Rv ${REALUSER} "$LGTARGET" >> $LOG
    else
        chown -Rv ${REALUSER} "$LGTARGET/extractedkdz" "$LGTARGET/extracteddz" >> $LOG
    fi

    # close yad listener
    kill $tail_pid

    if [ $EXERR -ne 0 ];then 
        F_ERR $FUNCNAME $EXERR "ERROR occured or aborted by user!"
    else
        [ x"$AUTOM" != "xauto" ] && $FYAD --width="500" --title="$YTITLE - SUCCESS" --image="$SICONS/ok_64x64.png" --text "\nAll partitions extracted!\n" \
            --button='Open target folder':"xdg-open '$LGTARGET/extracteddz'" \
            --button='Mount an image':"bash -c 'F_MOUNTPARTS $LGTARGET/extracteddz'" \
            --button=Close:0
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_EXTRACTKDZ

# check device for for antirollback bullshit (I'm still pissed off that a vendor is doing this! I mean HARDBRICK a phone ?? wtf LG?)
F_CDARB(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    # returns: <ARB>:<detection-success>

    DEVARBEMPTY=0
    PDARB=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --list | egrep "($PARB)" | head -n 1 | cut -d ":" -f1)
    F_LOG "$FUNCNAME: ARB partition seems to be: $PDARB"
    DEVARB=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --dump - $PDARB 2>> $LOG| strings | grep "0 SW_ID" |cut -d " " -f 2 | head -n 1 | sed -e 's/0\{16,16\}/zero/g' | tr -d "0")
    
    [ -z "$DEVARB" ] && DEVARB="0" && DEVARBEMPTY=1 && F_LOG "EMPTY ARB DETECTED:\n$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --dump /tmp/${PDARB}.err $PDARB && strings /tmp/${PDARB}.err | grep -C 1 SW_ID 2>&1)" && F_LOG "Please send this log and the $PDARB dump in /tmp/${PDARB}.err" && F_LOG "$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --debug 2>&1)" && F_LOG "$(lsusb -v)"
    [ "$DEVARB" == "zero" ] && DEVARB=0 && F_LOG "ARB valid and 0"
    F_LOG "$FUNCNAME: DEVARB=$DEVARB, DEVARBEMPTY=$DEVARBEMPTY"
    echo "${DEVARB}:${DEVARBEMPTY}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_CDARB

# dumps a single partition
F_DUMPPART(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2 args
    #
    # 1 => partition name
    # 2 => path to store

    [ -z $1 -o -z $2 ] && F_EXIT "$FUNCNAME missing args!" 3

    PNAME=$1
    BPTH="$2"
    BFL="${BPTH}/${PNAME}"

    [ ! -d "$BPTH" ] && mkdir -p "$BPTH"
    $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --dump $BFL $PNAME

}; export -f F_DUMPPART

# check for the UsU Unlock (G4 only)
F_CKUSU(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #
    (F_DUMPPART aboot /tmp/UsU/check 2>&1) >> $LOG
    REMAB=$(sha256sum /tmp/UsU/check/aboot | cut -d " " -f1)

    USUDET=0
    [ "$USUHASH" == "$REMAB" ] && USUDET=1
    F_LOG "$FUNCNAME: USU=$USUDET (1=yes, 0=no)"
    unset USUMNM
    [ $USUDET == 1 ] && USUMNM="$(F_USUMODEL)"
    echo "${USUDET}:${USUMNM}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_CKUSU

# check for the real modelname when UsU
F_USUMODEL(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #
    (F_DUMPPART raw_resources /tmp/UsU 2>&1) >> $LOG
    REMRR=$(dd if=/tmp/UsU/raw_resources skip=3145722 count=6 bs=1 2>>/dev/null | strings)
    F_LOG "$FUNCNAME: RR based USUMODEL=$REMRR"
    echo "${REMRR}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_USUMODEL

# check local file for antirollback bullshit
# (I'm still pissed off that LG is REALLY doing this! I mean HARDBRICK a phone ?? wtf LG? Its MY decision if I wanna use an outdated/insecure ROM version!)
F_CKARB(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #  
    # 1 => full path to the file to check

    ARBFILE="$1"

    if [ ! -f "$ARBFILE" ];then
        F_MSGE 700 "Missing required file to check for ARB\n  (checked this filename: $ARBFILE)!"
        echo "arb-detect-error"
    else
        KDZARB=$(strings "$ARBFILE" | egrep "[0-9] SW_ID" |cut -d " " -f 2 | cut -d "0" -f 8 |tr -d "0")
        [ -z "$KDZARB" ] && KDZARB=0
        F_LOG "KDZARB=$KDZARB"
        echo $KDZARB
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_CKARB

# check device model
F_CHKMODEL(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    # returns <connected-model>:<file-model>
    #
    # 1 => image/kdz file to compare

    KFILE="$1"
    [ -z "$KFILE" -o ! -f "$KFILE" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  KFILE missing for compare!"

    DEVINF=$(F_GETINFO)
    for i in $DEVINF;do
        case ${i/:*/} in
           model_name) LGMODEL=${i/*:/};;
        esac
    done
    KDZMODEL=$(dd if=$KFILE bs=512 count=10000 2>&1| strings | egrep -m1 -o '(LGLS[0-9]{3})|(LGVS[0-9]{3})|(LG-[H|F][0-9]{3})')
    if [ -z "$KDZMODEL" ] ;then
        RES="${LGMODEL}:unknown"
    else
        RES="${LGMODEL}:${KDZMODEL}"
    fi
    F_LOG "$FUNCNAME: $RES"
    echo $RES
    F_LOG "$FUNCNAME: ended"
} ; export -f F_CHKMODEL

# checks if UsU variable is readable and set correctly
F_USUVARVALID(){ F_LOG "$FUNCNAME: started"
    if [ "$LGUSU" == "yes" -o "$LGUSU" == "no" ];then echo 1; else echo 0; fi
 } ; export -f F_USUVARVALID

# verify device ARB and model results against folder / files ARB and model
# returns returncode of users choice or errors
F_VERIFYDARB(){
    F_LOG "$FUNCNAME: started with $@"
    IMGDIR="$1"
    
    CHKMRES=unknown
    
    # check device model of the given files
    DFIL=$(find "$IMGDIR" -name 'misc.*' | head -n 1 | grep misc \
      || find "$IMGDIR" -name 'aboot*' | head -n 1 | grep aboot \
      || find "$IMGDIR" -name 'mpt*' | head -n 1 | grep mpt \
      || echo ERROR)
    [ "$DFIL" != "ERROR" ] && F_LOG "$FUNCNAME: Will use $DFIL for model check" && CHKMRES=$(F_CHKMODEL "$DFIL")

    # check ARB
    ARBOK=0
    AFIL=$(find "$IMGDIR" -name 'sbl1.*' | head -n 1 | grep sbl1 \
      || find "$IMGDIR" -name 'rpm*' | head -n 1 | grep rpm \
      || find "$IMGDIR" -name 'tz*' | head -n 1 | grep tz \
      || find "$IMGDIR" -name 'aboot*' | head -n 1 | grep aboot \
      || echo ERROR)
    [ "$AFIL" != "ERROR" ] && F_LOG "$FUNCNAME: Will use $AFIL for ARB check" && KARB=$(F_CKARB "$AFIL")
    
    ARBOK=0
    DARB=$(F_CDARB)
    F_LOG "$FUNCNAME: KARB: $KARB, DARB: $DARB, \nCHKMRES: ${CHKMRES/*:} VS. ${CHKMRES/:*}"
    # verify the internal functions do not generate crap
    [ -z "$KARB" -o -z "$DARB" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  Device ARB or file-based ARB cannot be checked! ABORTED!!"
    # verify ARB
    [ "$KARB" -eq "${DARB/:*}" ] && ARBOK=1 && ARBINC=0 && F_LOG "$FUNCNAME: ARB is equal between files and device"
    [ "$KARB" -gt "${DARB/:*}" ] && ARBOK=1 && ARBINC=1 && F_MSGW 800 "Depending on the files you flash (e.g. bootloader) your ARB will be increased!\n\nThat means you can <b>never</b> rollback to a previous versions once flashed!\n\nRead more about ARB here:\n\n<a href='https://bit.do/antirollg4'>ARB explained</a>" >> /dev/null 2>&1
    [ "$KARB" -lt "${DARB/:*}" ] && ARBOK=0 && ARBINC=0 && F_MSGE 800 "The ARB of the files you are trying to flash is LOWER then your device!!! ABORTED!\n\nRead more about ARB here:\n\n<a href='https://bit.do/antirollg4'>ARB explained</a>" && F_EXIT "$FUNCNAME too low ARB" 3
    # a bulletproof method to avoid issues with any of the above (e.g. when KARB or DARB are not digits etc)
    [ "$ARBOK" -ne 1 ] && F_MSGE 500 "Issues regarding determining ARB! ABORTED!" && F_EXIT "$FUNCNAME: ARB check failed" 4

    # manual ARB verification by the user
    if [ -z "${CHKMRES/*:}" ] || [ -z "${CHKMRES/:*}" ]|| [ "${CHKMRES/:*}" == "unknown" ] || [ "${CHKMRES/*:}" != "${CHKMRES/:*}" ];then
        F_LOG "$FUNCNAME: file and device model does not match!!!"
        F_MSGW 800 "WARNING: <b><span color='#ff0000'>file and device model does not match!</span></b>\nDevice model:\t${CHKMRES/:*}\nFiles are for:\t\t${CHKMRES/*:}\n\nARB of your device compared with the files\nDevice:\t${DARB/:*}\nFiles:\t$KARB\n\nYou can doublecheck some known ARB <a href='https://bit.do/antirollg4'>here</a>\n\nDo you really want to continue and so FLASHing now?" "--button=Continue-may-HARDBRICK:99"
    else
        F_LOG "$FUNCNAME: file and device model does match"
        F_MSGOK 800 "<b>file and device</b> information match\nDevice model:\t${CHKMRES/:*}\nFiles are for:\t\t${CHKMRES/*:}\n\nARB of your device compared with the files\nDevice:\t${DARB/:*}\nFiles:\t$KARB\nYou can doublecheck some known ARB <a href='http://bit.do/antirollg4'>here</a>\n\n  Do you really want to continue and so FLASHing now?" "--button=Continue:99"
    fi
}; export -f F_VERIFYDARB

# flash a KDZ
F_FLASHKDZ(){ F_LOG "$FUNCNAME: started"
    # takes 5 arguments
    #
    #   1 => KDZ filename
    #   2 => Factory reset
    #   3 => Model check
    #   4 => ARB check
    #   5 => test mode

    LGKDZ="$1"
    LGFR="$2"
    LGCHKMOD="$3"
    LGARB="$4"
    LGDRY="$5"

    # autoextract kdz without userdata and cache
    KDZTMP=/tmp
    F_EXTRACTKDZ "$LGKDZ" "$KDZTMP" auto

    # test mode?
    if [ "$LGDRY" != "FALSE" ];then
        ($KDZMGR --batch --flash "$KDZTMP/extracteddz" --test 2>&1) | tee -a $LOG | $FYAD --title="$YTITLE - FLASH" --text-info --text "\n  <b><span color='#009900'>FLASHING KDZ (TEST)...</span></b>\n" --listen --tail --height=600 --width=900 --wrap --fore=blue --button="Next":0
        $FYAD --title="$YTITLE - FLASH" --text "\n  TEST run finished\n\n  Do you want to continue to FLASH in REAL now?" --button=FLASH:1 --button=Cancel:0
        [ $? -ne 1 ] && echo canceling.. && F_EXIT $FUNCNAME $?
    fi

    # check device connection
    F_CHKDEVCON

    # that one is required for flashing (the device must be connected and UsU state must be detected!)
    VARSET=$(F_USUVARVALID)
    if [ "$VARSET" -eq 0 ];then F_MSGE 500 "ERROR: Cannot determine UsU state?! aborted.."; F_EXIT "$FUNCNAME" 3; fi

    # recheck valid image files
    # TODO

    # verify ARB and model
    RET=$(F_VERIFYDARB "$KDZTMP/extracteddz")

    # abort when needed
    [ "$RET" != "99" ] && F_ERR $FUNCNAME 3 "\n  Aborted on user check verification"

    # abort when needed
    [ $? -ne 0 ] && F_ERR $FUNCNAME 3 "\n  Aborted on user check verification"

    # If all the above is fine: FLASH
    F_FLASHPART "$KDZTMP/extracteddz" auto

    # factory reset to avoid bootloop (cache gets deleted by FLASHPART already)
    # TODO: accept the taken user choice
    # DISABLED as WIPEPART will just clear the partition and do not FORMAT it (will produce bootloops etc) 
    #F_WIPEPART userdata ni

    F_MSG 600 "    KDZ flashing completed.\n    Check the log for details (Advanced Menu)"
    F_LOG "$FUNCNAME: ended"
}; export -f F_FLASHKDZ

# choose and flash partitions from a backup or extracted KDZ
F_FLASHPART(){ F_LOG "$FUNCNAME: started"
    # takes 1 optional argument
    #
    # 1 => image files path
    
    LGUSUOVERRIDE=false
    
    if [ -z "$1" ];then
        AIMGDIR=$($FYAD --width=600 --title="$YTITLE - FOLDER" --form \
                    --field="  Select the source folder":DIR \
                    --field="  UsU override\n  (will allow flashing of all partitions on UsU devices - leave unchecked if unsure!)":CHK \
                  $REALHOME \
                  $LGUSUOVERRIDE)
        IMGDIR=$(echo $AIMGDIR|cut -d '|' -f1)
        LGUSUOVERRIDE=$(echo $AIMGDIR|cut -d '|' -f2)
    else
        IMGDIR="$1"
    fi

    F_LOG "$FUNCNAME: IMGDIR=$IMGDIR"

    [ ! -d "$IMGDIR" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n Folder \n\n  $IMGDIR\n\n  does not exists?!"

    # check device connection
    F_CHKDEVCON    
    VARSET=$(F_USUVARVALID)
    if [ "$VARSET" -eq 0 ];then F_MSGE 500 "ERROR: Cannot determine UsU state?! aborted.."; F_EXIT "$FUNCNAME" 3; fi
    
    # create a list of *.image files
    if [ "$LGUSU" == "yes" ] && [ "$LGUSUOVERRIDE" == "false" -o "$LGUSUOVERRIDE" == "FALSE" ];then
      F_LOG "$FUNCNAME: UsU detected so will not display UsU relevant files (USUOVERRIDE=$LGUSUOVERRIDE)"
      IMGFILES=$(for ifile in $(find "$IMGDIR" -maxdepth 1 -type f -name '*.bin' -or -name '*.img' -or -name '*.image' -or -name '*.mbn' | tr " " "_" |egrep -vi "($FLASHIGNOREUSU)");do echo "${ifile##*/}";done | tr "\n" " ")
    else
      F_LOG "$FUNCNAME: will display all files (USUOVERRIDE=$LGUSUOVERRIDE)"
      IMGFILES=$(for ifile in $(find "$IMGDIR" -maxdepth 1 -type f -name '*.bin' -or -name '*.img' -or -name '*.image' -or -name '*.mbn' | tr " " "_" |egrep -vi "($FLASHIGNORE)");do echo "${ifile##*/}";done | tr "\n" " ")
    fi
    F_LOG "$FUNCNAME: image files: $IMGFILES"

    # give proper default choice for what to flash and what not
    shopt -s extglob
    unset IRES
    for f in $IMGFILES;do
        AVIMG="${f/:*}"
        APART=$(echo "${f/*:}" | sed -e 's/\.image//g;s/\.img//g;s/\.bin//g;s/\.mbn//g;s/mmcblk0p\(.*\)/\1/g')
        case $APART in
            ${PUNNEEDED})
              if [ -z "$IRES" ];then IRES="false\n${AVIMG}\n${APART}\nunneeded\n99"; else IRES="$IRES false\n${AVIMG}\n${APART}\nunneeded\n99" ;fi
            ;;
            ${PBOOTL})
              if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}</span>\n<span\tcolor='#ff0000'>bootloader</span>\n1"
              else
                IRES="$IRES true\n${AVIMG}\n${APART}\n<span\tcolor='#ff0000'>bootloader</span>\n1"
              fi
            ;;
            ${PDEVICE})
              # dangerous partitions contain device specific stuff, e.g. your IMEI and will not get written by a regular KDZ flash!
              if [ -z "$IRES" ];then 
                IRES="false\n${AVIMG}\n${APART}</span>\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              else 
                IRES="$IRES false\n${AVIMG}\n${APART}\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              fi
            ;;
            ${PSYSTEM})
            if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}\n<span\tcolor='#558000'>safe-to-flash</span>\n2"
            else
                IRES="$IRES true\n${AVIMG}\n${APART}\n<span\tcolor='#558000'>safe-to-flash</span>\n2"
            fi
            ;;
            *)
            if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}\nunknown-type\n2"
            else
                IRES="$IRES true\n${AVIMG}\n${APART}\nunknown-type\n2"
            fi
            ;;
        esac
    done

    F_LOG "$FUNCNAME: created yad list: $IRES"

    BTNRET=66
    while [ "$BTNRET" -eq 77 -o "$BTNRET" -eq 66 ];do
        if [ "$BTNRET" == 66 ];then
          FCHOOSENP=$(for files in $IRES;do echo -e "$files" ;done \
                      | $FYAD --height=800 --width=700 --title="$YTITLE - FOLDER" --text "\n  Select the partitions you want to flash\n  (the RECOMMENDED partitions to flash are CHECKED already!)\n\n\t<i>bootloader:</i>\t\twhen flashing ensure you select <b>ALL</b> parts of it - otherwise hard brick\n\t<i>dangerous:</i>\t\tcan reset unlocked devices, loosing IMEI etc!\n\t<i>unknown-type:</i>\tmeaning of that partition is unknown, use with care!\n\n  Hint: you can change the target partition by a double click - but do this only when you\n  <b>REALLY</b> know what you're doing!\n" \
                        --list --checklist \
                        --column="Flash":CHK \
                        --column="Image File":TXT \
                        --column="Target partition" \
                        --column="Type" \
                        --editable \
                        --editable-cols="3" \
                        --column=sort_int \
                        --hide-column=5 \
                        --listen \
                        --button="Deselect All":77 \
                        --button=FLASH:0 \
                        --button=Abort:99 )
          BTNRET="${PIPESTATUS[0]}"
          CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2-5 | tr "|" ":" | tr "\n" " ")
          F_LOG "$FUNCNAME BTNRET: $BTNRET"
        else 
            if [ "$BTNRET" == 77 ];then
              FCHOOSENP=$(for files in $IRES;do echo -e "${files/true/false}" ;done \
                         | $FYAD --height=800 --width=700 --title="$YTITLE - FOLDER" --text "\n  Select the partitions you want to flash\n  (the RECOMMENDED partitions to flash are CHECKED already!)\n\n\t<i>bootloader:</i>\t\twhen flashing ensure you select <b>ALL</b> parts of it - otherwise hard brick\n\t<i>dangerous:</i>\t\tcan reset unlocked devices, loosing IMEI etc!\n\t<i>unknown-type:</i>\tmeaning of that partition is unknown, use with care!\n\n  Hint: you can change the target partition by a double click - but do this only when you\n  <b>REALLY</b> know what you're doing!\n" \
                            --list --checklist \
                            --column="Flash":CHK \
                            --column="Image File":TXT \
                            --column="Target partition" \
                            --column="Type" \
                            --editable \
                            --editable-cols="3" \
                            --column=sort_int \
                            --hide-column=5 \
                            --listen \
                            --button="Select default":66 \
                            --button=FLASH:0 \
                            --button=Abort:99)
              BTNRET="${PIPESTATUS[0]}"
              CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2-5 | tr "|" ":" | tr "\n" " ")
              F_LOG "$FUNCNAME BTNRET: $BTNRET"
            else
              break
            fi
        fi
    done

    [ $BTNRET -ne 0 ] && F_MSGE 500 "Aborted by user" && F_EXIT "$FUNCNAME aborted by user" 3
    
    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_ERR $FUNCNAME 0 "No partition selected?"

    F_LOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    BLWARN=$(echo "$CHOOSENP"|tr " " "\n" | egrep -c "(bootloader|dangerous)" )
    if [ "$BLWARN" -gt 0 ];then
      RET=$(F_MSGW 600 "You have choosen\n\n\t<b>$BLWARN</b>\n\nfiles marked as bootloader or/and dangerous.\nFlashing those should only be done when you know what you do!" "--button=I-think-I-know-what-I-do:88")
      [ "$RET" != "88" ] && F_ERR $FUNCNAME 3 "Aborted by user"
    fi
    
    SORTEDP=$(echo "$CHOOSENP" |tr " " "\n" | sort -t : -k 3n | cut -d ":" -f 1-2 | tr "\n" " " )
    CHCOUNT=$(echo "$SORTEDP" |tr " " "\n" |grep -c :)

    F_LOG "sorted partitions: $SORTEDP -> $CHCOUNT"

    # verify ARB and model
    ARET=$(F_VERIFYDARB "$IMGDIR")
    
    # abort when needed
    [ "$ARET" != "99" ] && F_ERR $FUNCNAME 3 "Aborted on user check verification ($ARET)"

    UANS=$(F_MSGW 700 "Keep in mind that SALT flashes the partitions in RAW format which will take usually longer then i.e. when using LGup.\n(RAW means every single bit gets copied - so even unused disk space)\n\nSALT is ready and will flash these partitions:\n\n$(echo $SORTEDP | sed 's/\ /, /g')" "--button=FLASH:99")
    if [ $UANS -ne 99 ] || [ $CHCOUNT -eq 0 ] ;then
        F_MSGE 500 "Aborted by user or no partitions selected"
    else
        # FLASH
        CNT=0
        for img in $SORTEDP; do
            CNT=$((CNT+1))
            FFILE="$IMGDIR/${img/:*}"
            FPART=${img/*:}
            F_LOG "flashing: $FFILE to $FPART"
    
      # inform yad which partition we flash
      echo "#flashing: $FPART"
    
            F_LOG "$FUNCNAME: $FPART starting"
            $PYTHONBIN -u $LAFPATH/partitions.py ${CROPT} --batch --restore "$FFILE" $FPART 2>>$LOG | sed -u -e "s%:\([0-9]*\):\([0-9]*\)%,#$FPART: \1 KB / \2 KB%g;s/,/\n/g"  2>>$LOG
      FLASHERR=${PIPESTATUS[0]}
      if [ $FLASHERR -eq 0 ];then
        echo "100"
                    F_LOG "$FUNCNAME: $FPART finished"
                    [ $CNT -eq $CHCOUNT ] && echo '# ALL PARTITIONS FLASHED SUCCESSFULLY' && F_LOG "$FUNCNAME: All partitions flashed successfully"
      else
                    F_LOG "$FUNCNAME: $FPART FAILED with $FLASHERR"
        echo "# $FPART: FAILED"
              F_ERR $FUNCNAME 4 "DO NOT REBOOT YOUR DEVICE!\n  FLASHING PROBLEM OCCURED!!!\n  while flashing:\n\n  <b>$FPART</b>\n\nClick this button, then Upload: " 0 "--form --field=Upload-SALT-log!$SICONS/log_16x16.png:FBTN $SALTPATH/getlog" 
      fi
        done | $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FLASHING" --text="\n <b>Lean back, take a cup of coffee or sleep a bit. SALT is flashing now ...</b>\n (DO NOT REBOOT THE DEVICE while flashing or when an error occurs!)\n\n" --width 900 --progress --button='Close (WAIT until all is flashed)':1
        FLERR=${PIPESTATUS[0]}
    
        # check result
        if [ "$FLERR" -eq 0 ];then
            F_MSGOK 400 "Flashing was successful!"
        else
            F_MSGE 800 "FLASHING ENDED WITH ERROR: $FLERR\n\nCheck Debug Log in SALT main screen!\nDO NOT REBOOT THE DEVICE TO AVOID HARD BRICK!!!!\n\nIf you haven't already uploaded the debug log click this button, then Upload:\n" "--form --field=Upload-SALT-log!$SICONS/log_16x16.png:FBTN $SALTPATH/getlog" 
        fi
    
        # TODO: md5 verify?        
        
        # wipe cache
        # disabled as it will clear the partition but not format it - leading into a non booting device until formatted manually
        #F_WIPEPART cache ni || F_MSGE 400 "Wiping cache ended with an error: $WIPERR\n\nCheck Debug Log in SALT main screen."
        
        # sync filesystems
        F_SYNC || F_MSGE 400 "Syncing filesystems ended with an error: $WIPERR\n\nCheck and upload the debug Log in SALT advanced menu.\nDO NOT REBOOT THE DEVICE!"
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_FLASHPART

# check/ensure device is connected
F_CHKDEVCON(){ F_LOG "$FUNCNAME: started"
    # takes no argument
    $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  uname -m\0' --rawshell 2>&1 >> $LOG 
    RET=${PIPESTATUS[0]}
    if [ $RET -ne 0 ];then
        RES=$(F_MSG 700 "NO DEVICE CONNECTED?\nIf you have connected your device ensure that it is in DOWNLOAD mode\n(<u>not</u> fastboot, <u>not</u> recovery, <u>not</u> booted Android)" "--image=$SICONS/warning_64x64.png --button=Example-Picture:99 --button=Skip:11 --button=Retry:22")
        F_LOG "$FUNCNAME: msge result = $RES"
        F_LOG "$FUNCNAME: lsusb output = $(lsusb |grep 1004)"
        [ $RES -eq 99 ] && [ ! -z $SUDO_USER ] && sudo -u $SUDO_USER xdg-open "$SICONS/dlmode.png"
        [ $RES -eq 99 ] && [ -z $SUDO_USER ] && xdg-open "$SICONS/dlmode.png"
        RET=$RES
    else
        F_LOG "$FUNCNAME: Device seems to be connected!"
    fi
    F_LOG "RET: $RET"
    return $RET
}; export -f F_CHKDEVCON

# open a shell
F_SHELL(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    F_CHKDEVCON
    if [ $? -eq 0 ];then
        F_ELOG "device connected... Opening shell now!"
        xterm -e "cd $LAFPATH && echo -e '\n*****************\nTYPE the word exit TO CLOSE THIS WINDOW\n*********************\n\n'; $PYTHONBIN $LAFPATH/lglaf.py ${CROPT}"
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_SHELL

# start dialog for kdz extract
F_STARTKDZ(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    EXCHOICES=$($FYAD --title="$YTITLE - EXTRACT" --width=800 --always-print-result --text \
        "\n  This will extract any KDZ file for you with just a click\n" \
        --form \
        --field="  KDZ file":FL --file-filter="KDZ files (*.kdz)| *.kdz *.KDZ"\
        --field="  Target directory\nHINT: Ensure you have enough free disk space":DIR \
        undef /tmp/salt_kdz \
        )
    F_ELOG "returned: $EXCHOICES"
    KDZFILE=$(echo "$EXCHOICES" | cut -d '|' -f 1)
    TARGDIR=$(echo "$EXCHOICES" | cut -d '|' -f 2)
    UDATA=$(echo "$EXCHOICES" | cut -d '|' -f 4)
    KCACHE=$(echo "$EXCHOICES" | cut -d '|' -f 5)
    
    F_ELOG "KDZFILE = $KDZFILE, TARGDIR = $TARGDIR, UDATA = $UDATA, KCACHE = $KCACHE"

    [ ! -f "$KDZFILE" ] && F_ERR "EXTRACTKDZ" 3 "$KDZFILE does not exists or is not readable!"
    [ ! -z "$TARGDIR" ] && [ ! -d "$TARGDIR" ] && echo mkdir -p $TARGDIR

    F_EXTRACTKDZ "$KDZFILE" "$TARGDIR" $UDATA $KCACHE

    F_ELOG $FUNCNAME ended
};export -f F_STARTKDZ

# Update everything!
F_UPDATE(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #

    # let the user switch between stable and develop
    AA=$($FYAD --title="$YTITLE - SETUP" --item-separator='|' --text "\n  Here you can choose between stable and development branches of SALT and its backends" --form \
            --field="  SALT branch\t":CBE "$BRSALT|$BROSALT" \
            --field="  kdztools branch\t":CBE "$BRKDZ|$BROKDZ" \
            --field="  lglaf branch\t":CBE "$BRLAF|$BROLAF"\
            --button=Update:0 --button=Cancel:1 \
         )

    [ $? -ne 0 ] && F_LOG "Aborted on user request" && F_EXIT $FUNCNAME 4

    BRSALT=$(echo "$AA"| cut -d "|" -f 1)
    BRKDZ=$(echo "$AA"| cut -d "|" -f 2)
    BRLAF=$(echo "$AA"| cut -d "|" -f 3)

    CNT=0
    for u in ${SALTPATH}:$BRSALT ${LAFPATH}:$BRLAF ${KDZTOOLS}:$BRKDZ; do 
        CNT=$((CNT+1))
        F_LOG "$FUNCNAME: updating ${u/:*} on branch ${u/*:} ..."
        echo "${CNT}:5"
        cd ${u/:*}
        echo "${CNT}:10"
        F_LOG "$($GIT checkout ${u/*:} 2>&1)"
        $GIT pull 2>&1 | tee -a $LOG | sed "s/^/${CNT}:#/g"
        test ${PIPESTATUS[0]} -eq 0 && echo "${CNT}:100"
    done | $FYAD --title="$YTITLE - UPDATING" --text="\n  <b>Be patient while SALT freshen up...</b>\n  (if a progress bar do NOT get to 100% a manual update is required)\n\n" --width 800 --multi-progress --bar="SALT codebase":norm --bar="LGLAF codebase":norm --bar="kdztools codebase":norm --button=Close

    F_MSGW 600 "You must restart SALT if you have updated or changed the <b>SALT</b> branch before the changes become active." "--fixed"
    F_LOG "$FUNCNAME: ended"
}; export -f F_UPDATE

# wipe a partition
F_WIPEPART(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2 arguments
    #
    # 1 => partition name to wipe
    # 2 => interactive (ia) or noninteractive (ni) mode. if not given we assume interactive!

    WPART="$1"
    ITP="$2"

    if [ "$ITP" == "ni" ];then 
        F_LOG "$FUNCNAME: wiping $WPART in noninteractive mode"
        $PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --wipe $WPART 2>&1 | tee -a $LOG
    else
        F_LOG "$FUNCNAME: wiping $WPART in interactive mode"
        F_MSG 400 "Do you really want to wipe out <b>$WPART</b>?" "--button=Yes:0 --button='wtf NO never':1"
        [ $? -eq 0 ] && $PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --wipe $WPART 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - WIPING" --width=800 --height=200 --text-info --listen --wrap --button=Close
    fi
    F_SYNC
}; export -f F_WIPEPART

# execute commands via lglaf
F_LAFEXEC(){ F_LOG "$FUNCNAME: started with these arguments: $@"
    # takes 1 argument

    EXECMD="$1"
    RET=$($PYTHONBIN ${LAFPATH}/lglaf.py ${CROPT} -c "'!EXEC  ${EXECMD}\0'" --rawshell)
    echo $RET
}; export -f F_LAFEXEC

# flush file system buffers
F_SYNC(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    F_LAFEXEC sync
}; export -f F_SYNC

# take a REAL nandroid backup of the device
F_BACKUP(){ F_LOG "$FUNCNAME: started with these arguments: $@"
    # takes no arguments

    # define backup type
    $FYAD --width=550 --image="$SICONS/backup.png" --title="$YTITLE - BACKUP" --text "\n  Choose your backup type!\n\n  Full:\t\tlike Basic but includes any size\n  Custom:\tLet you choose the partitions to backup\n  Basic:\t\twill just backup partitions up to a size of $BMAXDEF MB" --button=Full:1 --button=Custom:3 --button=Basic:2 --buttons-layout=center
    BAKTYPE=$?

    F_LOG "$FUNCNAME: DEBUG: List partitions:\n$($PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --list --batch)"

    COMPLSIZE=0
    case $BAKTYPE in
        1) BAKTNAME=Full
            BMAX=0
            for size in $($PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --list --batch | cut -d ":" -f6 | $TRBIN "\n" " ");do
                F_LOG "$FUNCNAME: DEBUG: adding $size to $COMPLSIZE"
                COMPLSIZE=$((COMPLSIZE + $size))
            done
        ;;
        2) BAKTNAME=Basic
            BMAX=$((BMAXDEF * 1024))
            for size in $($PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --list --batch | cut -d ":" -f6 | $GREPBIN -v $BMAX | $TRBIN "\n" " ");do
                if [ $size -le $BMAX ];then
                    F_LOG "$FUNCNAME: DEBUG: adding $size to $COMPLSIZE"
                    COMPLSIZE=$((COMPLSIZE + $size))
                else
                    F_LOG "$FUNCNAME: skipping $size as its smaller then $BMAX"
                fi
            done
        ;;
        3) BAKTNAME=Custom
            BMAX=0
            IRES=$(F_GETPARTS)

            BTNRET=66
            while [ "$BTNRET" -eq 77 -o "$BTNRET" -eq 66 ];do
                if [ "$BTNRET" == 66 ];then
                  FCHOOSENP=$(for slice in $IRES;do echo -e "$slice" | sed 's/false/true/g' ;done \
                            | $FYAD --height=800 --width=1000 --title="$YTITLE - BACKUP" \
                            --text "\n  Select partition(s) to backup:\n"\
                            --list --checklist \
                            --column="Selection":CHK \
                            --column="Partition":TXT \
                            --column="#" \
                            --column="Start sector" \
                            --column="End sector" \
                            --column="UID" \
                            --column="Type" \
                            --column="Size" \
                            --column="t_nr" \
                            --hide-column=9 \
                            --listen --no-selection \
                            --button="Deselect All":77 \
                            --button=Backup:0 \
                            --button=Abort:3)
                  BTNRET="${PIPESTATUS[0]}"
                  CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2,3,8 | tr "|" ":"| tr "\n" " ")
                  F_LOG "$FUNCNAME BTNRET: $BTNRET"
                else
                    if [ "$BTNRET" == 77 ];then
                      FCHOOSENP=$(for slice in $IRES;do echo -e "$slice" | sed 's/true/false/g';done \
                                | $FYAD --height=800 --width=1000 --title="$YTITLE - BACKUP" \
                                --text "\n  Select partition(s) to backup:\n"\
                                --list --checklist \
                                --column="Selection":CHK \
                                --column="Partition":TXT \
                                --column="#" \
                                --column="Start sector" \
                                --column="End sector" \
                                --column="UID" \
                                --column="Type" \
                                --column="Size" \
                                --column="t_nr" \
                                --hide-column=9 \
                                --listen --no-selection \
                                --button="Select All":66 \
                                --button=Backup:0 \
                                --button=Abort:3)
                      BTNRET="${PIPESTATUS[0]}"
                      CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2,3,8 | tr "|" ":"| tr "\n" " ")
                      F_LOG "$FUNCNAME BTNRET: $BTNRET"
                    else
                      break
                    fi
                fi
            done

            F_LOG "CHOOSENP: $CHOOSENP"
        
            F_LOG "CERR: $CERR"
            [ $CERR -ne 0 ] && F_MSGE 400 "Aborted by user!" && F_EXIT $FUNCNAME $CERR
        
            CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |cut -d ":" -f 1-2 | grep -c :)
            [ $CHCOUNT -lt 1 ] && F_MSGE 400 "No partition selected?" && F_EXIT $FUNCNAME $CHCOUNT
        
            F_ELOG "choosen partitions: $CHOOSENP -> $CHCOUNT"
        
            SORTEDP=$(echo "$CHOOSENP" |tr " " "\n" | sort -t : -k 3n | cut -d ":" -f 1,3 | tr "\n" " ")
            BAKPARTS=$(echo "$SORTEDP" | tr " " "\n" |cut -d ":" -f1 | tr "\n" " ")
            BSIZES=$(echo "$SORTEDP" | tr " " "\n" |cut -d ":" -f2 | tr "\n" " ")
            CHCOUNT=$(echo "$SORTEDP" |tr " " "\n" |grep -c :)
        
            F_LOG "$FUNCNAME: sorted partitions: $SORTEDP . In sum: $CHCOUNT partitions"
            F_LOG "$FUNCNAME: BSIZES: $BSIZES"

            for size in $BSIZES;do
                # $($PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --list --batch | egrep "($SORTEDP)" | cut -d ":" -f6 | $TRBIN "\n" " ");do
                MSZ="${size/*_}"
                NSZ="${size/_*}"
                case $MSZ in
                    KB) SZ=$((NSZ));;
                    MB) SZ=$((NSZ*1024));;
                    GB) SZ=$((NSZ*1024*1024));;
                    *) SZ=0;;
                esac
                F_LOG "$FUNCNAME: DEBUG: adding $SZ to $COMPLSIZE"
                COMPLSIZE=$((COMPLSIZE + $SZ))
            done
        ;;
        *) F_EXIT "$FUNCNAME $BAKTYPE" 3
        ;;
    esac
    F_LOG "$FUNCNAME: DEBUG: choosen mode: $BAKTYPE, COMPLSIZE: $COMPLSIZE"
    COMPLSIZEMB=$((COMPLSIZE / 1024))

    [ "$COMPLSIZEMB" -eq 0 -o -z "$COMPLSIZEMB" ] && F_MSGE 500 "Calculated target size is too small ($COMPLSIZEMB)!\nUpload and share the debug log!" && F_EXIT "$FUNCNAME" 4

    TFREE=0
    while [ "$TFREE" -lt "$COMPLSIZEMB" ];do
        BANS=$($FYAD --width=800 --image="$SICONS/backup.png" --title="$YTITLE - BACKUP" --text="\n Backup your device in <b>$BAKTNAME</b> mode.\n\n The choosen backup type will require: <span color='#ff0000'><b>$COMPLSIZEMB MB</b></span> of free disk space!\n\n" --form \
        --field="Target directory":CDIR "${REALHOME}/salt_backup" \
        --button=Continue:0 --button=Abort:99)
        BRET=$?
        [ $BRET -ne 0 ] && F_EXIT "$FUNCNAME Aborted on users request" $BRET
        BTDIR="${BANS/|*}"
        F_LOG "$FUNCNAME: choosen target directory was $BTDIR"

        [ ! -d "$BTDIR" ] && F_LOG "$FUNCNAME: Target dir <$BTDIR> does not exists. Will create it" && mkdir -p "$BTDIR"

        # verify disk space
        TFREE=$(F_CHKFREE "$BTDIR")
        F_LOG "$FUNCNAME: TFREE $TFREE vs. $COMPLSIZEMB"
        [ "$TFREE" -lt "$COMPLSIZEMB" ] && F_MSGE 500 "Wake up dude!\n\nThe target directoy:\n\n$BTDIR\n\n<span color='#ff0000'><b>HAS NOT ENOUGH FREE SPACE!</b></span>\n\nFree space:\t<b>$TFREE MB</b>\nRequired:\t<b>$COMPLSIZEMB MB</b>\n\nTry again!"
    done
 
    F_LOG "$FUNCNAME: choosen backup type was $BAKTYPE, $BAKTNAME, $BMAX KB, backup size: $COMPLSIZEMB, backup path: $BTDIR"
    F_LOG "$FUNCNAME: Target directory has enough free space!"
    $FYAD --width=500 --image="$SICONS/backup.png" --title="$YTITLE - BACKUP" --text "\n  READY!\n\n  Free space:\t<b>$TFREE MB</b>\n  Required:\t<b>$COMPLSIZEMB MB</b>\n\n  Click START to begin the backup now. " --button=START:0 --button=Abort:2
    BRET=$?
    [ $BRET -ne 0 ] && F_EXIT "$FUNCNAME Aborted on users request" $BRET

    case $BAKTNAME in
        Basic|Full)
            $PYTHONBIN ${LAFPATH}/extract-partitions.py ${CROPT} --batch --outdir "$BTDIR" --max-size $BMAX 2>&1 | tee -a $LOG | $FYAD --image="$SICONS/salt_logo_128x128.png" --title="$YTITLE - $BAKTNAME BACKUP" --text="\n  <b>SALT is backing up your device...</b>\n\n" --width 900 --progress --button='Close (WAIT until you see All finished)':0
            BERR=${PIPESTATUS[0]}
            if [ "$BERR" -ne 0 ];then
                F_MSGE 500 "Backup ($BAKTNAME) incomplete! Check the log."
                return 3
            else
                F_MSGOK 400 "Backup ($BAKTNAME) completed successfully"
            fi
        ;;
        Custom)
            [ -z "$BAKPARTS" ] && F_MSGE 500 "Backup partition list is empty!\nUpload and share the debug log!" && F_EXIT "$FUNCNAME" 4
            F_LOG "$FUNCNAME: resulting partion list: $BAKPARTS"

            # open yad listener
            echo 0> /tmp/t_${BAKTNAME}
            tail -f /tmp/t_${BAKTNAME} | $FYAD --image="$SICONS/salt_logo_128x128.png" --title="$YTITLE - BACKUP" --text="\n  <b>SALT is now taken a custom backup...</b>\n" --width 900 --multi-progress --multi-progress --bar="  Current Partition" --bar="  Overall state" --watch-bar2 --button='Close (WAIT until FINISHED)':0 --auto-close &
            tail_pid=$!
            CNT=0
            BERR=0

            for part in $BAKPARTS;do
                CNT=$((CNT+1))
                echo "1:0" >> /tmp/t_${BAKTNAME}
                echo "1:#dumping $part partition..." >>/tmp/t_${BAKTNAME}
                echo "2:#processing $part ($CNT of $CHCOUNT)" >>/tmp/t_${BAKTNAME}
                $PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --batch --dump "$BTDIR/${part}.img" $part 2>&1 | tee -a $LOG | cut -d ":" -f1 | sed 's/^/1:/g' >> /tmp/t_${BAKTNAME}
                ERR=$?
                BERR=$((BERR + $ERR))
                F_LOG "$FUNCNAME: $part finished with error code: $ERR"
                CNTPERC=$(($CNT * 100 / $CHCOUNT))
                echo "2:$CNTPERC" >>/tmp/t_${BAKTNAME}
                echo "2:#$part backup ($CNT of $CHCOUNT) done!">>/tmp/t_${BAKTNAME}

               # ensure we do not overflow lafd
                sleep 2
                [ $CNT -eq $CHCOUNT ] && echo '2:# BACKUP FINISHED!' >>/tmp/t_${BAKTNAME} && F_LOG "$FUNCNAME: Custom Backup finished"
            done
            rm /tmp/t_${BAKTNAME}
            if [ "$BERR" -ne 0 ];then
                F_MSGE 500 "Backup ($BAKTNAME) incomplete! Check the log."
            else
                F_MSGOK 400 "Backup ($BAKTNAME) completed successfully"
            fi
        ;;
        *)
            F_MSGE 500 "Backup $BAKTNAME ($BAKTYPE) is an unknown type! Check the log."
            return 3
        ;;
    esac

    # ensure regular users can work with the backup
    chown -Rv ${REALUSER} "${REALHOME}/salt_backup" >> $LOG

    VERSUPP=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  md5sum /dev/block/bootdevice/by-name/\0' --rawshell 2>&1 | cut -d ' ' -f 1 | grep -vi Hello)
    if [ -z "$VERSUPP" ];then
        F_MSGW 600 "\n  Your device/firmware does not support verification of the backup sorry." 
    else
        unset VERANS
        VERANS=$(F_MSGOK 600 "\n  Your device supports md5sum verification!\n  Do you want to verify your just created backup?" "--button=Verify:2")
        F_LOG "$FUNCNAME: VERANS was $VERANS"
        [ "$VERANS" == "2" ] && F_VERIFYBAK "$BTDIR"
    fi
}; export -f F_BACKUP

# verify a backup folder with reality
F_VERIFYBAK(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #
    # mandantory:
    # 1 => path to the backup images (can be img,image,bin,mbn,mmcblk0p* files)

    VDIR=$1
    [ ! -d "$VDIR" ] && F_MSGE 650 "$VDIR does not exists!\nHow am I supposed to use these files existing only in your head?" && F_EXIT "$FUNCNAME no VDIR" 3

    DIRFILES=$(for v in $(find "$VDIR" -maxdepth 1 -type f -name '*.bin' -or -name '*.img' -or -name '*.image' -or -name 'mmcblk0p*' -or -name '*.mbn' | tr " " ","); do echo "$v";done)

    F_LOG "$FUNCNAME: detected files: $DIRFILES"
    CHCOUNT=$(echo "$DIRFILES" | egrep -c '^.+')
    F_LOG "$(echo \"$DIRFILES\" | egrep -c '^.+')"
    F_LOG "detected files: $DIRFILES -> $CHCOUNT"

    [ $CHCOUNT -lt 1 ] && F_MSGE 400 "$FUNCNAME: No valid image files found\n(valid are: bin, img, image, mbn, mmcblk0p*)!" && F_EXIT "$FUNCNAME: exited" 3


    SORTEDF=$(echo "$DIRFILES" |tr " " "\n" | sort | tr "\n" " " )
    CHCOUNT=$(echo "$SORTEDF" |tr " " "\n" |egrep -c '^.+')

    F_ELOG "sorted partitions: $SORTEDF -> $CHCOUNT"

    CNT=0
    BAKOK=()
    BAKWARNING=()
    BAKERROR=()

    # open yad listener
    echo 0> /tmp/t 
    tail -f /tmp/t | $FYAD --title="$YTITLE - VERIFY" --text="\n  <b>SALT is now verifying the backup...</b>\n  (just wait until you see: <b><span color='#ff0000'>VERIFICATION FINISHED</span></b>)\n" --width 900 --progress --button='Close (WAIT until FINISHED)':0 --auto-close &
    tail_pid=$!

    for vfile in $SORTEDF;do
        CNT=$((CNT+1))
        vfileloc=$(echo "${vfile}"| tr "," " ")
        echo "#${vfileloc/*\/} generating md5 ..." >>/tmp/t
        LOCFILE=$(md5sum "$vfileloc" | cut -d " " -f1)
        echo "#${vfileloc/*\/} md5: $LOCFILE" >>/tmp/t
        vfilerem=$(echo "${vfileloc/*\/}" | tr "," " " | sed -e 's/\.image//g;s/\.img//g;s/\.mbn//g;s/\.bin//g')
        F_LOG "$FUNCNAME: vfile: ${vfile}, vfileloc: $vfileloc, LOCFILE: $LOCFILE, vfilerem: $vfilerem"

        if [ -z "$vfilerem" ];then
            vfilerem=$(echo "${vfileloc}" | tr "," " " | sed -e 's/mmcblk0p\(.*\)/\1/g')
            REMFILE=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  md5sum /dev/block/bootdevice/by-num/p'${vfilerem}'\0' --rawshell 2>&1 | cut -d ' ' -f1)
        else
            LAFEXEC='!EXEC  md5sum /dev/block/bootdevice/by-name/${vfilerem}\0'
            REMFILE=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  md5sum /dev/block/bootdevice/by-name/'${vfilerem}'\0' --rawshell 2>&1 | cut -d ' ' -f1)
        fi
        F_LOG "$FUNCNAME: vfilerem: $vfilerem, REMFILE: $REMFILE"
        if [ -z "$LOCFILE" -o -z "$REMFILE" ];then
            F_LOG "$FUNCNAME: ${vfile/*\/} verify not possible as one or both hashes are empty (LOCFILE: $LOCFILE , REMFILE: $REMFILE)!"
            echo "#${vfile/*\/} no md5 verify!">>/tmp/t
            BAKWARNING+=("${vfile/*\/}\n")
        else
            if [ "$LOCFILE" == "$REMFILE" ];then
                F_LOG "$FUNCNAME: ${vfile/*\/} verify OK ($LOCFILE == $REMFILE)!"
                echo "#${vfile/*\/} verify OK!">>/tmp/t
                BAKOK+=("${vfile/*\/}\n")
                F_LOG "${BAKOK[@]}"
            else
                F_LOG "$FUNCNAME: #${vfile/*\/} verify ERROR (($LOCFILE != $REMFILE))!"
                echo "#${vfile/*\/} verify ERROR!" >>/tmp/t
                BAKERROR+=("${vfile/*\/}\n")
            fi
        fi
        # ensure we do not overflow lafd
        sleep 2
        CNTPERC=$(($CNT * 100 / $CHCOUNT))
        echo $CNTPERC >>/tmp/t
        [ $CNT -eq $CHCOUNT ] && echo '# VERIFICATION FINISHED!' >>/tmp/t && F_LOG "$FUNCNAME: Verification finished"
    done
    # close yad listener
    kill $tail_pid

    F_LOG "Success\n${BAKOK[@]}\nWarning\n${BAKWARNING[@]}\nErrors\n${BAKERROR[@]}"
    F_LOG "Success(#): ${#BAKOK[@]}, Warnings(#): ${#BAKWARNING[@]}, Errors(#): ${#BAKERROR[@]}"
    BAKOKYAD=$(echo "${BAKOK[@]}")
    BAKWARNYAD=$(echo "${BAKWARNING[@]}")
    BAKERRYAD=$(echo "${BAKERROR[@]}")
    $FYAD --title="$YTITLE - BAK VERIFY" --width=600 --center --text="\n\tVerifying completed!\n\tClick on the corresponding buttons to display details\n\n" --form \
            --field="\t${#BAKOK[@]}":RO OK \
            --field="\t${#BAKWARNING[@]}":RO WARNING \
            --field="\t${#BAKERROR[@]}":RO ERROR \
            --field=Details:FBTN "$FYAD --image=$SICONS/ok_64x64.png --width=800 --title=\"$YTITLE - OK\" --text=\"\nThese partitions were successfully verified (md5 matched):\n\n ${BAKOKYAD}\" --button=Close" \
            --field=Details:FBTN "$FYAD --image=$SICONS/warning_64x64.png --width=800 --title=\"$YTITLE - WARNINGS\" --text=\"\nThese files cant be verified (no md5 on partition possible):\n\n ${BAKWARNYAD}\" --button=Close" \
            --field=Details:FBTN "$FYAD --image=$SICONS/error.png --width=800 --title=\"$YTITLE - ERRORS\" --text=\"\nThese files are corrupt (md5 mismatch):\n\n ${BAKERRYAD}\" --button=Close" \
            --columns=2 --button=Close
}; export -f F_VERIFYBAK

# check if we run already and if not create a lock 
F_EGO(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    FRET=1
    [ -f $LOCKFILE ] && FRET=$(F_MSG 500 "\n  Oops... SALT seems to be running already!\n  Do you want me to ignore this (not recommended)?" "--image=$SICONS/error.png --button=Ignore:1 --button=Close:0")
    [ $FRET -ne 1 ] && F_LOG "$FUNCNAME: Aborted on users request" && exit 123  # no regular F_EXIT here
    # create a lock file
    date > $LOCKFILE && F_LOG "$FUNCNAME: $LOCKFILE created"
}; export -f F_EGO

# about/support screen
F_ABOUT(){ F_LOG "$FUNCNAME: started"
    # takes no args

    $FYAD --image="$SICONS/salt_logo_128x128.png" --title="$YTITLE - ABOUT" --width=800 --height=500 --fixed --text \
"\n  $TNAME is based on:\n\t- <a href='https://sourceforge.net/projects/yad-dialog'>YAD</a> - without this no GUI\n\
\t- the awesome <a href='https://github.com/Lekensteyn/lglaf'>LGLAF</a> code by Peter Wu\n\
\t- <a href='https://github.com/ehem/kdztools'>kdztools</a> by Elliott Mitchell\n\
\t- <b>MANY</b> enhancements by steadfasterX (including this GUI)\n\n\
  ${TNAME} sources:\n\
\t- <a href='https://github.com/steadfasterX/salt'>$TNAME</a>\n\
\t- <a href='https://github.com/steadfasterX/lglaf'>Patched LGLAF</a>\n\
\t- <a href='https://github.com/steadfasterX/salt'>Patched kdztools</a>\n\n\
  $TNAME support: <a href='https://tinyurl.com/SALTatXDA'>XDA thread</a>\n\n\
  Special credits:\n\
\t- <a href='https://github.com/tuxuser/'>tuxuser</a> for making LAF communication on Nougat possible and for his great support!\n\n\
  Images/Icons:\n\
\t- SALT logo is created by <a href='https://github.com/steadfasterX'>steadfasterX</a> and licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0/'>CC BY-SA 4.0</a>.\n\
\t- CR icon by RRZEicons <a href='https://creativecommons.org/licenses/by-sa/3.0'>CC BY-SA 3.0</a> from Wikimedia Commons. Modified in size." \
        --button=Close:0
}; export -f F_ABOUT

# flash a kdz
F_STARTKDZFL(){ F_LOG "$FUNCNAME: started"
    # takes no args

    FLCHOICES=$($FYAD --title="$YTITLE - FLASH" --always-print-result --width=800 --text "\n  When proceeding you accept that there is no guarantee for nothing - nowhere.\n  I do my best to avoid problems but we all are humans right?\n  You do this on your own responsibility and own risk no matter what.\n\n  Select a KDZ file to flash:" --form \
        --field="":FL --file-filter="KDZ files (*.kdz)| *.kdz *.KDZ" \
        --field="\n":LBL \
        --field="Factory Reset\t(if  *unchecked*  may result in bootloop)":CHK \
        --field="Model Check\t(if  *unchecked*  may result in HARD BRICK)":CHK \
        --field="ARB Check\t(if  *unchecked*  may result in HARD BRICK)":CHK \
        --field=:LBL \
        --field="TEST run\t\t(will  *not*  flash anything)":CHK \
        undef true true true true true true\
        --button="Agree &amp; Continue":0 \
        --button="Cancel":1 \
        )
    FLERR=$?
    [ $FLERR -ne 0 ] && F_EXIT flashing-select $FLERR 
 
    LGKDZ=$(echo "$FLCHOICES" | cut -d '|' -f 1)
    LGFR=$(echo "$FLCHOICES" | cut -d '|' -f 3)
    LGCHKMOD=$(echo "$FLCHOICES" | cut -d '|' -f 4)
    LGARB=$(echo "$FLCHOICES" | cut -d '|' -f 5)
    LGDRY=$(echo "$FLCHOICES" | cut -d '|' -f 7)

    F_ELOG "LGKDZ = $LGKDZ, LGFR = $LGFR, LGCHKMOD = $LGCHKMOD, LGARB = $LGARB, LGDRY = $LGDRY"

    [ ! -f "$LGKDZ" ] && F_ERR flashing-kdz-invalid 3 "\n  <b>ERROR</b>\n\n  The file\n  $LGKDZ\n  does not exist!\n"

    F_CHKDEVCON
    if [ $? -eq 0 ];then
        F_ELOG "device connected... going on!"
        F_FLASHKDZ "$LGKDZ" "$LGFR" "$LGCHKMOD" "$LGARB" "$LGDRY"
    else
        F_MSG 600 "\n  ERROR!\n\n  NO DEVICE CONNECTED?\n  If you have connected your device ensure that it is in DOWNLOAD mode\n  (not fastboot, not recovery, not booted Android)" "--button=Return:0"
    fi
}; export -f F_STARTKDZFL

# showing a advanced menu
F_ADVMENU(){ F_LOG "$FUNCNAME: started with $@"
    # takes 1 arg
    #
    # 1 => LGMODEL
    
    LGMODEL=$1
    F_LOG "$FUNCNAME: main YAD_PID is $YAD_PID"

    $FYAD --title="$YTITLE" --width=1000 --image="$SICONS/salt_logo_128x128.png" --text "\n  <b>$TFULLNAME</b>\n\n <b><span color='#ff0000'>THIS IS AN ADVANCED Menu</span></b>\n\nUse these options here with <b><span color='#ff0000'>CARE!</span></b>\n\n(mouse-over on a button for details)\n" \
        --form --columns=2\
        --field="SALT debug log!$SICONS/log_16x16.png":FBTN "$SALTPATH/getlog" \
        --field="$CRBTN!$SICONS/cr_30x30.png!Change the detection of challenge/response: Auto, forced yes, forced no":FBTN "bash -c 'F_CRRESTART $YAD_PID $CRMODE'" \
        --field="Convert an image (ZIP)!!Extract and convert sparse Android data images (.dat/.br) into a readable filesystem image and mount it":FBTN "bash -c F_EXTRACTDAT" \
        --field="Mount an image file!!This will let you mount android image files (system,userdata,..)":FBTN "bash -c F_MOUNTPARTS" \
        --field="Open a shell!$SICONS/terminal_30x30.png!Open an adb-like shell while in download mode":FBTN "bash -c F_SHELL" \
        --field="<span color='#ff0000'>Wipe</span> partition(s)!!EXTREMELY DANGEROUS - CAN EASILY BRICK YOUR DEVICE":FBTN "bash -c F_DELPART" \
        --field="Show your partitions!!This will just list your current partitions":FBTN "bash -c F_LISTPARTS" \
        --field="Unlock G4 (UsU)!$SICONS/salt_logo_30x30.png!Unofficial secureboot-off/steadfasterX Unlock":FBTN "bash -c 'F_DOUSU $LGMODEL'" \
        --button="Support / Licensing / Credits!$SICONS/log_16x16.png":"bash -c F_ABOUT" \
        --button="Close"

}; export -f F_ADVMENU

# mount a partition menu
F_MOUNTPARTS(){ F_LOG "$FUNCNAME: started"
    # takes 1 arg
    #
    # optional:
    # 1 => full path to image file
    
    ISRC=undef
    [ ! -z "$1" ] && ISRC="$1/click-here-2-select-a-file"
 
    CHOICE=$($FYAD --title="$YTITLE - MOUNT" --width=800 --always-print-result --text \
        "\n  Choose your image file you want to mount\n" \
        --form \
        --field="  Image file":FL --file-filter="Image (*.img)| *.img *.IMG *.bin *.mbn *.image" "$ISRC"\
        --field="  Mountpoint (don't touch unless you know why)" "/mnt/salt_mnt" \
        --button=Abort:99 \
        --button=Next:0 \
        )
    [ $? -eq 99 ] && F_MSGW 500 "Aborted by user" && F_EXIT $FUNCNAME 42

    F_LOG "returned: $CHOICE"
    IMGFILE=$(echo "$CHOICE" | cut -d '|' -f 1)
    MNTPNT=$(echo "$CHOICE" | cut -d '|' -f 2)

    F_LOG "IMGFILE = $IMGFILE, MNTPNT = $MNTPNT"

    [ ! -f "$IMGFILE" ] && F_ERR "$FUNCNAME" 3 "$IMGFILE does not exists or is not readable!"

    F_MOUNTIMG "$IMGFILE" "$MNTPNT"
  
}; export -f F_MOUNTPARTS

# sparse Android data image (.dat) and it's transfer list 
F_EXTRACTDAT(){ F_LOG "$FUNCNAME: started"
    # takes no args

    EXCHOICES=$($FYAD --title="$YTITLE - Choose ROM" --width=800 --always-print-result --text \
        "\n  Choose your ROM zip file\n" \
        --form \
        --field="  ROM zip file":FL --file-filter="ROM (*.zip)| *.zip *.ZIP" undef\
        --field="  Working directory":DIR "/tmp" \
        --field="  Auto-Mount resulting image file":CHK true \
        --field="  Mountpoint (don't touch unless you know why)" "/mnt/android_image" \
        --button=Abort:99 \
        --button=Next:0 \
        )
    [ $? -eq 99 ] && F_MSGW 500 "Aborted by user" && F_EXIT $FUNCNAME 42

    F_LOG "returned: $EXCHOICES"
    ZIPFILE=$(echo "$EXCHOICES" | cut -d '|' -f 1)
    TARGDIR=$(echo "$EXCHOICES" | cut -d '|' -f 2)
    MNTWANT=$(echo "$EXCHOICES" | cut -d '|' -f 3)
    CMNTPNT=$(echo "$EXCHOICES" | cut -d '|' -f 4)

    F_ELOG "ZIPFILE = $ZIPFILE, TARGDIR = $TARGDIR"

    [ ! -f "$ZIPFILE" ] && F_ERR "$FUNCNAME" 3 "$ZIPFILE does not exists or is not readable!"
    [ ! -z "$TARGDIR" ] && [ ! -d "$TARGDIR" ] && echo mkdir -p $TARGDIR

    EXCHOICES2=$(for i in $(unzip -Z1 "$ZIPFILE" '*.new*');do echo -e "false\n${i}" ;done | $FYAD --title="$YTITLE - Choose DAT" --width=800 --always-print-result --text \
        "\n  The following dat file(s) has/have been found in your zip file\n  Choose the system dat file you wanna extract and convert\n" \
        --list --radio-list \
        --column="Selection":RD \
        --column="Filename" \
        --print-column=2 \
        --button=Abort:99 \
        --button=Next:0
        )
    [ $? -eq 99 ] && F_MSGW 500 "Aborted by user" && F_EXIT $FUNCNAME 42
    F_LOG "returned: $EXCHOICES2"

    EXFILE=$(echo "$EXCHOICES2" | cut -d '|' -f 1)
    BRC=$(echo "$EXFILE" |grep -c "\.br")
    if [ "$BRC" -eq 1 ];then
        if [ ! -f "$BROTLI" ];then
            F_MSGE 500 "You're trying to extract an Oreo 8.1 dat file\nwhich requires the Google tool <a href='https://github.com/google/brotli'>brotli v1.x or higher!!!</a>\n\nPlease install it first:\n\n\t- in FWUL/Arch/Manjaro:\n\t  sudo pacman -S brotli\n\n\t- on Ubuntu/Debian/Mint:\n\t  sudo apt-get install brotli" "--selectable-labels --height=400 --fixed"
            F_EXIT $FUNCNAME 3
        else
            F_LOG "Brotli required and found!"
        fi
    fi

    [ -z "$EXFILE" ] && F_MSGE 500 "No file choosen?!"

    CHIMGNAME="${EXFILE/\.*}"
    MNTPNT="${CMNTPNT}_$CHIMGNAME"

    F_LOG "ZIPFILE = $ZIPFILE, TARGDIR = $TARGDIR, EXFILE = $EXFILE, CHIMGNAME = $CHIMGNAME, MNTPNT = $MNTPNT"

    F_UNZIP "$ZIPFILE" "$TARGDIR" "$EXFILE ${CHIMGNAME}.transfer.list"
    if [ $BRC -eq 0 ];then
         F_CONVDAT "DAT" "${TARGDIR}/${CHIMGNAME}.transfer.list" "${TARGDIR}/$EXFILE" "$TARGDIR" "${CHIMGNAME}.converted.img"
    else
        F_CONVDAT "BR" "${TARGDIR}/${CHIMGNAME}.transfer.list" "${TARGDIR}/$EXFILE" "$TARGDIR" "${CHIMGNAME}.converted.img"
        F_CONVDAT "DAT" "${TARGDIR}/${CHIMGNAME}.transfer.list" "${TARGDIR}/${CHIMGNAME}.new.dat" "$TARGDIR" "${CHIMGNAME}.converted.img"
    fi
    if [ "$MNTWANT" == "TRUE" ];then
        F_MOUNTIMG "$TARGDIR/${CHIMGNAME}.converted.img" "$MNTPNT"
    else
        F_MSGOK 600 "Image has been extracted!\nYou can find it here:\n\n<b>${TARGDIR}/</b>"
    fi

    F_LOG "$FUNCNAME ended"
}; export -f F_EXTRACTDAT

# mounting a given image file
F_MOUNTIMG(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2 args
    #
    # required:
    # 1 => filename to mount (full path)
    # 2 => mountpoint
    MFILE="$1"
    MPNT="$2"

    [ ! -f "$MFILE" ] && F_ERR "$FUNCNAME" 3 "$MFILE does not exists or is not readable!"
    [ ! -d "$MPNT" ] && F_LOG "$FUNCNAME: mountpoint $MPNT does not exits.. will be created now!" && mkdir -p $MPNT

    # check if the mnt point is in use
    mount | grep "$MPNT" >> /dev/null
    if [ $? -eq 0 ];then
        UMANS=$(F_MSGW 500 "Mountpoint $MPNT is in use!\nDo you want to unmount it now?" "--button=Unmount:99")
        if [ $UMANS -eq 99 ];then
            F_UMNT $MPNT
            F_MSGW 500 "You have to re-open the mount menu to proceed"
        fi
    else
        # mount
        df --output=fstype "$MFILE" 2>&1 | grep vboxsf >> $LOG
        if [ $? -eq 0 ];then
            F_MSGE 500 "VirtualBox shared folders are not supported!\n.. and no this is <b>not</b> SALT's fault!\n\nWorkaround: copy the image file to your Desktop\n\nCheck SALT logfile for any further details."
        else
            mount -v -o loop "$MFILE" $MPNT 2>&1 >> $LOG 
            if [ $? -eq 0 ]; then
                $FYAD --width=1000 --image="$SICONS/salt_logo_128x128.png" --title="$YTITLE - MOUNT" --text="  Image file:\n\t<b>$MFILE</b>\n\n  has been mounted to\n\t<b>$MNTPNT</b>\n\n" \
                    --form \
                    --field="Browse Image":FBTN "xdg-open $MPNT" \
                    --field="Unmount Image":FBTN "bash -c 'F_UMNT $MPNT'" \
                    --button=Close:0
            else
                F_MSGE 500 "Image could not be mounted to $MNTPNT.Is this even an mountable image?\n\nCheck SALT logfile for any further details."
            fi
        fi
    fi
    F_LOG "$FUNCNAME ended"
};export -f F_MOUNTIMG

# unmount image/partitions, ..
F_UMNT(){ F_LOG "$FUNCNAME: started with '$@'"
    # takes 1 arg
    #
    # required:
    # 1 => mountpoint to unmount
    
    MPNT="$1"
    mount | grep "$MPNT" >> /dev/null
    if [ $? -eq 0 ];then
        umount -v "$MPNT" 2>&1 >> $LOG
        if [ $? -eq 0 ];then F_MSGOK 500 "$MPNT unmounted!"; else F_MSGE 500 "Error on unmounting!\nCheck logfile in the advanced menu!";fi
    else
        F_MSGE 500 "Sorry but there is no mountpoint:\n\n$MPNT"
    fi
}; export -f F_UMNT

# unzip files from a ZIP :P
F_UNZIP(){ F_LOG "$FUNCNAME: started with '$@'"
    # takes 3 args
    #
    # required:
    # 1 => ZIP filename
    # 2 => target directory
    #
    # optional:
    # 3 => file(s) to extract

    ZIPF="$1"
    TARGD="$2"
    ZFILE="$3"
    [ ! -f "$ZIPF" ] && F_ERR "$FUNCNAME" 3 "$ZIPF does not exists or is not readable!"
    if [ -z "$TARGD" ];then
        F_ERR "$FUNCNAME" 3 "Missing target dir!"
    else
        [ ! -d "$TARGDIR" ]&& echo mkdir -p "$TARGDIR"
    fi

    F_LOG "Will extract $ZFILE from $ZIPF to $TARGD (overwriting mode!)"

    unzip -o "$ZIPF" -d "$TARGD" $ZFILE 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - EXTRACT" --text="\n  Extracting:\n  <b>${ZIPF/*\/}</b>\n  Please be patient depending on your PC this can take a while...\n" --width=800 --progress --progress-text="extracting ${ZFILE} ..." --pulsate  --no-buttons --auto-close
    [ $? -ne 0 ] && F_MSGE 500 "Error $? occured / Aborted by user while extracting $ZFILE" && F_EXIT $FUNCNAME 3
    F_LOG "Extracting finished successfully"

}; export -f F_UNZIP

# convert an android sparse file
F_CONVDAT(){ F_LOG "$FUNCNAME: started with $@"
    # takes 4 args
    #
    # required:
    # 1 => BR (brotli) or DAT (sda2img) mode
    # 2 => transfer list (full path)
    # 3 => sparse filename (full path)
    # 4 => target directory
    # 5 => target image file name

    CMODE="$1"
    TFLIST="$2"
    SFIL="$3"
    TDIR="$4"
    IMGTYPE="${5/\.*}"
    RFILE="${TDIR}/$5"

    F_LOG "$FUNCNAME: $CMODE, $TFLIST, $SFIL, $TDIR, $RFILE, $IMGTYPE"
    [ ! -f "$TFLIST" -o ! -f "$SFIL" -o ! -d "$TDIR" ] && F_MSGE 500 "missing file! $TFLIST, $SFIL, $TDIR," && F_EXIT $FUNCNAME 3

    case "$CMODE" in
        DAT) F_LOG "DAT mode detected"
             $PYTHONBIN $SDATBIN "$TFLIST" "$SFIL" "$RFILE" 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - CONVERT" --text="\n  Converting:\n  <b>${SFIL/*\/}</b>\n  Please be patient depending on your PC this can take a while...\n" --width=800 --progress --progress-text="converting ${SFIL} ..." --pulsate --no-buttons --auto-close
        ;;
        BR) F_LOG "BR mode detected"
            $BROTLI --force --decompress -o "${TDIR}/${IMGTYPE}.new.dat" "$SFIL" 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - CONVERT" --text="\n  Converting:\n  <b>${SFIL/*\/}</b>\n  Please be patient depending on your PC this can take a while...\n" --width=800 --progress --progress-text="converting ${SFIL} ..." --pulsate --no-buttons --auto-close 
        ;;
        *) F_MSGE 500 "no valid mode selected! ABORTED"; F_EXIT $FUNCNAME 3
        ;;
    esac
    [ $? -ne 0 ] && F_MSGE 500 "Error $? occured / Aborted by user while converting $SFIL" && F_EXIT $FUNCNAME 3
    F_LOG "Converting finished successfully"
}; export -f F_CONVDAT

# list your partitions nicely
F_LISTPARTS(){ F_LOG "$FUNCNAME: started"
    # takes no args

    IRES=$(F_GETPARTS)

    for files in $IRES;do echo -e "$files" | egrep -vi "(true|false)" ;done | $FYAD --height=800 --width=1000 --title="$YTITLE - PARTITIONS" --text "\n  Your partitions:\n" --list \
            --column="Partition":TXT \
            --column="#" \
            --column="Start sector" \
            --column="End sector" \
            --column="UID" \
            --column="Type" \
            --column="Size" \
            --column="Unused" \
            --listen --no-selection \
            --hide-column=8 \
            --button=Close:0 
}; export -f F_LISTPARTS

# show your partitions
F_GETPARTS(){ F_LOG "$FUNCNAME: started"
    # takes no args

    PARTLIST=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --batch)

    # make preselections
    unset IRES
    for f in $PARTLIST;do

        PNAME="${f/:*}"
        PARTN=$(echo "${f}" | cut -d ":" -f 2)
        SSEC=$(echo "${f}" | cut -d ":" -f 3)
        ESEC=$(echo "${f}" | cut -d ":" -f 4)
        PARTUID=$(echo "${f}" | cut -d ":" -f 5)
        PARTSIZEB=$(echo "${f}" | cut -d ":" -f 6)

        F_LOG "PARTSIZEB is: $PARTSIZEB"
        if [ $PARTSIZEB -gt 1048576 ];then
            PARTSIZE="$((PARTSIZEB/1024/1024))_GB"
        else
            if [ $PARTSIZEB -gt 1024 ];then
                PARTSIZE="$((PARTSIZEB/1024))_MB"
            else
                PARTSIZE="${PARTSIZEB}_KB"
            fi
        fi
        [ -z "$PARTSIZE" ] && PARTSIZE="unknown_size"

        F_LOG "${PNAME},${PARTN},${SSEC},${ESEC},${PARTUID},$PARTSIZE"

        shopt -s extglob
        case $PNAME in
            ${PUNNEEDED})
              if [ -z "$IRES" ];then IRES="false\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunneeded\n99"; else IRES="$IRES false\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunneeded\n${PARTSIZE}\n99" ;fi
            ;;
            ${PBOOTL})
              if [ -z "$IRES" ];then IRES="true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nbootloader\n1"; else IRES="$IRES true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nbootloader\n${PARTSIZE}\n1" ;fi
            ;;
            ${PDEVICE})
              if [ -z "$IRES" ];then 
                IRES="false\n${PNAME}\n${PARTN}${SSEC}\n${ESEC}\n${PARTUID}\n</span>\n<span\tcolor='#ff0000'>dangerous</span>\n${PARTSIZE}\n88"
              else 
                IRES="$IRES false\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\n<span\tcolor='#ff0000'>dangerous</span>\n${PARTSIZE}\n88"
              fi
            ;;
            ${PSYSTEM})
            if [ -z "$IRES" ];then
                IRES="true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\n<span\tcolor='#558000'>system-partition</span>\n${PARTSIZE}\n2"
            else
                IRES="$IRES true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\n<span\tcolor='#558000'>system-partition</span>\n${PARTSIZE}\n2"
            fi
            ;;
            *)
            if [ -z "$IRES" ];then
                IRES="true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunknown-type\n${PARTSIZE}\n2"
            else
                IRES="$IRES true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunknown-type\n${PARTSIZE}\n2"
            fi
            ;;
        esac
    done

    F_LOG "($FUNCNAME) created yad list: $IRES"
    echo "$IRES"
}; export -f F_GETPARTS

# factory reset a device
F_FACRESET(){ F_LOG "$FUNCNAME: started"
    # takes 1 (optional) argument
    # when no arg given we assume interactive mode
    #
    # 1 => interactive (ia) or not (ni)

    if [ -z $1 ];then WMODE=ia; else WMODE=$1; fi

    # clean userdata
    F_WIPEPART userdata $WMODE || F_MSGE 400 "Wiping userdata ended with an error: $WIPERR\n\nCheck debug Log in SALT advanced menu."
    # wipe cache
    F_WIPEPART cache $WMODE || F_MSGE 400 "Wiping cache ended with an error: $WIPERR\n\nCheck debug Log in SALT advanced menu."
}

# erase partitions
F_DELPART(){ F_LOG "$FUNCNAME: started"
    # takes no args
    
    IRES=$(F_GETPARTS) 
    CHOOSENP=$((for files in $IRES;do echo -e "$files" | sed 's/true/false/g' ;done | $FYAD --height=800 --width=1000 --title="$YTITLE - WIPE" --text "\n  Select partition(s) to WIPE:\n" --list  --checklist\
            --column="Selection":CHK \
            --column="Partition":TXT \
            --column="#" \
            --column="Start sector" \
            --column="End sector" \
            --column="UID" \
            --column="Type" \
            --column="Size" \
            --column="sort_int" \
            --listen --no-selection \
            --hide-column=9 \
            --button=WIPE:0 \
            --button=Abort:3) | cut -d "|" -f 2,3,9 | tr "|" ":")
    CERR=${PIPESTATUS[0]}
    F_LOG "CHOOSENP: $CHOOSENP"

    F_LOG "CERR: $CERR"
    [ $CERR -ne 0 ] && F_MSGE 400 "Aborted by user!" && F_EXIT $FUNCNAME $CERR

    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_MSGE 400 "No partition selected?" && F_EXIT $FUNCNAME $CHCOUNT

    F_ELOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    SORTEDP=$(echo "$CHOOSENP" |tr " " "\n" | sort -t : -k 3n | cut -d ":" -f 1-2 | tr "\n" " ")
    SORTEDPH=$(echo "$SORTEDP" | tr " " "\n" |cut -d ":" -f1 )
    CHCOUNT=$(echo "$SORTEDP" |tr " " "\n" |grep -c :)

    LCERR=$(F_MSGW 600 "Last chance to stop!\n\n<b><span color='#ff0000'>THIS CAN EASILY HARD BRICK YOUR DEVICE IF YOU DO NOT KNOW WHAT YOU'RE DOING!</span></b>\n\nThese partitions will be erased when continuing:\n\n$SORTEDPH\n\nAre you totally sure?" "--button=WIPE-THEM:99")
    [ $LCERR -ne 99 ] && F_MSGE 400 "Aborted on user request!" && F_EXIT $FUNCNAME 4
    
    F_ELOG "sorted partitions: $SORTEDP -> $CHCOUNT"
    for w in $SORTEDP; do
        echo 0
        echo "#${w/:*}"
        sleep 2
        echo 40
        ($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --wipe ${w/:*} 2>&1) >> $LOG
        if [ $? -ne 0 ];then
            echo "#ERROR: while wiping ${w/:*}"
            F_MSGE 600 "ERROR while wiping ${w/:*} !! " && F_EXIT $FUNCNAME 4
        else
            echo "#wiped ${w/:*} successfully"
            echo 100
        fi
    done | $FYAD --title="$YTITLE - ERASING" --text="\n  <b>SALT is now erasing selected partitions...</b>\n  (if the progress bar does NOT get up to 100%: DO NOT REBOOT THE DEVICE!)\n\n" --width 900 --progress --button='Abort':1 --button="Finish (wait until all is done)":0
    EERR=${PIPESTATUS[0]}
    if [ $EERR -eq 0 ];then
        F_MSGOK 400 "All partitions wiped successfully:\n\n$SORTEDPH"
    else
        F_MSGE 600 "  Problems occured while wiping (EERR: $EERR) or ABORTED by user!\n  Check log and do not poweroff the device until you fixed this!"
    fi
}; export -f F_DELPART

# flashing action for UsU
F_USUFLASH(){ F_LOG "$FUNCNAME: started with this args: $@"
    # takes 1 arg
    #
    # 1 => type of flashing
    USUDIRECT=undef

    # kill parent window
    kill -s SIGUSR1 $YAD_PID >> $LOG 2>&1

    FLTYPE=$1
    case $FLTYPE in
        sdcard) F_LOG "$FUNCNAME: Will load UsU from the external SD card.."
            USUSRC=/storage/external_SD/aboot_UsU.img
            DLMSRC=/storage/external_SD/laf_UsU.img
            RRSRC=/storage/external_SD/rawres_UsU.img
            $FYAD --width=800 --title="$YTITLE - UsU from sdcard" \
                --text="\n   Please do the following (without leaving download mode!):\n\n\t- take out the sdcard <b>now</b>\n\t- insert it in again\n\t- wait 5 sec\n\t- press 'Next'" \
                --button="Next":0 \
                --button=Abort:99
            [ $? -ne 0 ] && F_EXIT $FUNCNAME $?
        ;;
        internal) F_LOG "$FUNCNAME: Will load UsU from the internal storage.."
            USUSRC=/data/media/0/Download/aboot_UsU.img
            DLMSRC=/data/media/0/Download/laf_UsU.img
            RRSRC=/data/media/0/Download/rawres_UsU.img
            $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  umount /data\0' --debug --rawshell 2>&1 >> $LOG
            $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  mount -t ext4 /dev/block/bootdevice/by-name/userdata /data\0' --debug --rawshell 2>&1 >> $LOG
            F_LOG "$FUNCNAME: userdata mounting finished"
        ;;
        direct) F_LOG "$FUNCNAME: Will flash UsU directly to the device..."
            USUWHERE=$($FYAD --image="$SICONS/salt_logo_64x64.png" --width=600 --title="$YTITLE - UsU" --text="\n    To minimize the risk of taken down by LG:\n    SALT does <b>not</b> come bundled with the UsU unlock files.\n\n    You have to download them manually and tell me the location:\n     1. <b><span color='#ff0000'> aboot </span></b>UsU file\n" \
                        --form --field='    UsU unlock file (aboot UsU)':FL --file-filter='aboot UsU file | aboot_UsU.img' \
                        --button=Next:0)
            LASTDIR=$(echo $USUWHERE |cut -d "|" -f1 | sed 's#/aboot_UsU.img##g')
            DLMWHERE=$($FYAD --image="$SICONS/salt_logo_64x64.png" --width=600 --title="$YTITLE - UsU" --text="\n    2. <b><span color='#ff0000'> laf </span></b>UsU file\n" \
                        --form --field='    UsU download mode file (laf UsU)':FL --file-filter='laf UsU file | laf_UsU.img' "${LASTDIR}/laf_UsU.img"\
                        --button=Next:0)
            LASTDIR=$(echo $DLMWHERE |cut -d "|" -f1 | sed 's#/laf_UsU.img##g')
            RRWHERE=$($FYAD  --image="$SICONS/salt_logo_64x64.png" --width=600 --title="$YTITLE - UsU" --text="\n    3. <b><span color='#ff0000'> rawres </span></b>UsU file\n" \
                        --form --field='    UsU misc. file (rawres UsU)':FL --file-filter='rawres UsU file | rawres_UsU.img' "${LASTDIR}/rawres_UsU.img"\
                        --button=Next:0)
            USUDIRECT=$(echo $USUWHERE |cut -d "|" -f1)
            USUSRC="$USUDIRECT"
            DLMDIRECT=$(echo $DLMWHERE |cut -d "|" -f1)
            DLMSRC="$DLMDIRECT"
            RRDIRECT=$(echo $RRWHERE |cut -d "|" -f1)
            RRSRC="$RRDIRECT"
        ;;
        *) F_ELOG "$FUNCNAME: no valid FLTYPE choosen!!!"
           F_EXIT $FUNCNAME 2
        ;;
    esac

    # verify UsU file existence
    $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - VERIFY" --text="\n  SALT is searching for the UsU files ...\n" --width=500 --progress --progress-text="searching ..." --pulsate --no-buttons --auto-close &
    PROGY=$! 
    if [ "$FLTYPE" == "direct" ];then
        if [ !  -f "$USUDIRECT" ] || [ !  -f "$DLMDIRECT" ] || [ !  -f "$RRDIRECT" ];then
            F_MSGE 700 "   Oops?!\n\n   You have choosen\n\n   $USUDIRECT (aboot)\n   $DLMDIRECT (laf)\n   $RRDIRECT (rawres)\n\n   but I can not find it...!\n\n   Try another method or ensure you stored it to the correct path."
            kill $PROGY
            F_EXIT $FUNCNAME 3
        else
            F_LOG "USUDIRECT: $USUDIRECT , DLMDIRECT: $DLMDIRECT, RRDIRECT: $RRDIRECT"
            kill $PROGY
        fi
    else
        USUEX=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls '$USUSRC'\0' --rawshell)
        DLMEX=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls '$DLMSRC'\0' --rawshell)
        RREX=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls '$RRSRC'\0' --rawshell)
        F_LOG "$FUNCNAME: USUEX=$USUEX, DLMEX=$DLMEX, RREX=$RREX"
        kill $PROGY
        if [ -z "$USUEX" ]||[ -z "$DLMEX"]||[ -z "$RREX"];then 
            F_MSGE 700 "   Oops?!\n\n   You have choosen\n\n   $USUSRC\n   $DLMSRC\n   $RRSRC\n\n   but I can not find it...!\n\n   Try another method or ensure you stored it to the correct path."
            ($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls /storage/external_SD/*.img /data/media/0/Download/*.img\0' --rawshell 2>&1) >> $LOG 
            F_EXIT $FUNCNAME 5
        fi
    fi
    
    # give feedback to the impatient users
    FLPBAR=/tmp/flbbar
    echo 10> $FLPBAR
    tail -f $FLPBAR | $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FLASHING" --text="\n  Fasten your seat belt!\n  SALT is flashing UsU ...\n" --width=500 --progress --progress-text="activating UsU ..." --no-buttons --auto-close &
    PROGY=$!
    
    # verify writing in general (before actually writing to REAL aboot!!)
    F_DUMPPART abootbak "/tmp/UsU/before"
    TESTPRE=$(sha256sum /tmp/UsU/before/abootbak | cut -d " " -f1)
    F_LOG "$FUNCNAME: abootbak before flashing: $TESTPRE"
    echo "#pre-checking ..." >> $FLPBAR
    if [ "$FLTYPE" == "direct" ];then
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --restore "$USUDIRECT" abootbak --batch 1>> $FLPBAR 2>> $LOG
    else
        F_LOG '!EXEC  dd if='$USUSRC' of=/dev/block/mmcblk0 seek=248832 bs=512\0'
        $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$USUSRC' of=/dev/block/mmcblk0 seek=248832 bs=512\0' --rawshell 2>&1 >> $LOG
    fi
    echo "#verifying pre-check ..." >> $FLPBAR
    F_DUMPPART abootbak "/tmp/UsU/after"
    TESTAFTER=$(sha256sum /tmp/UsU/after/abootbak | cut -d " " -f1)
    # verify test result
    F_LOG "$FUNCNAME: abootbak after flashing: $TESTAFTER"
    if [ "$TESTAFTER" == "$USUHASH" ];then
        F_LOG "$FUNCNAME: PERFECT! We can really write on this device!"
    else
        if [ "$TESTAFTER" == "$TESTPRE" ];then
            kill $PROGY
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $TESTAFTER"
            F_MSGE 800 "   PRE-TEST failure!\n\n   Sorry but flashing seems to be blocked on your device.\n   Nothing has changed! Pls use the <b>QFIL</b> method instead."
            F_EXIT $FUNCNAME 2
        else
            kill $PROGY
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $TESTAFTER"
            F_MSGE 500 "   PRE-TEST failure!\n\n   This should never happen but if you see this\n   a VERY critical error happened!\n\n   DO NOT POWER OFF YOUR DEVICE!\n\n   Instead use LGup to flash a KDZ otherwise you may hard brick!"
            F_EXIT $FUNCNAME 2
        fi
    fi

    # real flash
    echo 0 >> $FLPBAR
    echo "#preparing flashing! ..." >> $FLPBAR
    F_DUMPPART aboot "/tmp/UsU/before"
    F_DUMPPART laf "/tmp/UsU/before"
    F_DUMPPART raw_resources "/tmp/UsU/before"
    ABPRE=$(sha256sum /tmp/UsU/before/aboot|cut -d " " -f1)
    DLMPRE=$(sha256sum /tmp/UsU/before/laf|cut -d " " -f1)
    RRPRE=$(sha256sum /tmp/UsU/before/raw_resources|cut -d " " -f1)
    F_LOG "$FUNCNAME: checksums before flashing UsU:\naboot before:\n$ABPRE\nlaf before: $DLMPRE\nrr before: $RRPRE"
    if [ "$FLTYPE" == "direct" ];then
        F_LOG 'flashing aboot and laf directly...'
        echo "#flashing UsU unlock ..." >> $FLPBAR
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --debug --restore "$USUDIRECT" aboot --batch 1>> $FLPBAR 2>> $LOG
        echo "#flashing UsU laf ..." >> $FLPBAR
        F_LOG "flashing laf from $DLMDIRECT ..."
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --debug --restore "$DLMDIRECT" laf --batch 1>> $FLPBAR 2>> $LOG

        echo "#flashing UsU rawres ..." >> $FLPBAR
        F_LOG "flashing rawres from $RRDIRECT ..."
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --debug --restore "$RRDIRECT" raw_resources --batch 1>> $FLPBAR 2>> $LOG
    else
        # we have no progress indicator when flashing from the device storage so we need to pulsate..
        kill $PROGY
        tail -f $FLPBAR | $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FLASHING" --text="\n  Fasten your seat belt!\n  SALT is flashing UsU ...\n" --width=500 --progress --progress-text="starting ..." --pulsate --no-buttons --auto-close &
        PROGY=$!
        F_LOG "flashing aboot from $USUSRC..."
        echo "#flashing UsU unlock ..." >> $FLPBAR
        $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$USUSRC' of=/dev/block/mmcblk0 seek=237568 bs=512\0' --rawshell 2>&1 >> $LOG
        echo "#flashing UsU laf ..." >> $FLPBAR
        F_LOG "flashing laf from $DLMSRC ..."
        $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$DLMSRC' of=/dev/block/mmcblk0 seek=393216 bs=512\0' --rawshell 2>&1 >> $LOG

        RRSEEKSTART=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --batch |grep "raw_resources:" |cut -d ":" -f 3)
        F_LOG "FUNCNAME: raw resources from partition listing:"
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --batch |grep "raw_resources:" >> $LOG 2>&1
        # G4 must have rr between sector 770000 and 870000
        if [ "$RRSEEKSTART" -lt 770000 ] || [ "$RRSEEKSTART" -gt 870000 ];then
            F_MSGW 700 "Can not identify a valid seek start for rawres! SKIPPED!\nYou have to flash the rawres_UsU.img in fastboot to fully enable UsU"
        else
            echo "#flashing UsU rawres ..." >> $FLPBAR
            F_LOG "flashing rawres from $RRSRC with seekstart: $RRSEEKSTART ..."
            $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$RRSRC' of=/dev/block/mmcblk0 seek='$RRSEEKSTART' bs=512\0' --rawshell 2>&1 >> $LOG
        fi
    fi
    # verify real flashing
    echo "#verifying UsU unlock ..." >> $FLPBAR
    F_DUMPPART aboot "/tmp/UsU/after"
    F_DUMPPART laf "/tmp/UsU/after"
    F_DUMPPART raw_resources "/tmp/UsU/after"
    ABAFTER=$(sha256sum /tmp/UsU/after/aboot|cut -d " " -f1)
    LAFAFTER=$(sha256sum /tmp/UsU/after/laf|cut -d " " -f1)
    RRAFTER=$(sha256sum /tmp/UsU/after/raw_resources|cut -d " " -f1)
    F_LOG "$FUNCNAME: after flashing:\naboot = $ABAFTER\nlaf = $LAFAFTER\nrr = $RRAFTER"

    source "$HASHES"
    if [ $? -ne 0 ];then
        F_LOG "ERROR: including $HASHES"
        F_MSGE 700 "Cannot include UsU hash table!\nABORTED!"
        kill $PROGY
        F_EXIT $FUNCNAME 4
    fi
    F_LOG "UsU hashes included successfully!\nLAF: $DLMHASH\nrr: $RRHASH"
    
    # verify the whole result
    kill $PROGY
    if [ "$ABAFTER" == "$USUHASH" ];then
        if [ "$DLMHASH" != "$LAFAFTER" ]||[ "$RRHASH" != "$RRAFTER" ];then
            F_MSGW 700 "Some parts of UsU couldn't be flashed!\n\nLAF:\n$DLMHASH (wanted)\n$DLMPRE (before)\n$LAFAFTER (after)\n\nrawres:\n$RRHASH (wanted)\n$RRPRE (before)\n$RRAFTER (after)"
            $FYAD --width=700 --fixed --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FB WAY" \
                --text "SALT will reboot your device now but it needs\n\n<b>YOU</b>\n\nto boot properly:\n\n<b>Before</b> pressing Continue:\n\npress the <b>Volume DOWN</b> button NOW\nand <b>keep</b> it pressed!!\n\nWhen you click continue wait until you see the fastboot mode\n(a black screen and a couple of lines).\nThen you can release that button." \
                --button=Continue:99
            if [ $? -eq 99 ];then
                F_LOG "REBOOT INITIATED by USER!" && $PYTHONBIN ${LAFPATH}/lglaf.py ${CROPT} -c '!CTRL RSET'
                F_USUFLFB laf "${DLMSRC%/*}" "${DLMSRC##*/}"
                F_USUFLFB raw_resources "${RRSRC%/*}" "${RRSRC##*/}"
                $FYAD --title="$YTITLE - FB FLASH" --width=700 --fixed --image="$SICONS/salt_logo_64x64.png" --text "Good! Now press\n\n <b>Volume UP (!!)</b> button\n\nand <b>keep</b> it pressed until you see the download mode.\nThen press Continue." --button=Continue
                $FBBIN reboot
                # check device connection
                F_CHKDEVCON
            else
                F_MSGE 600 "Aborted by user"
            fi
        fi
        F_MSGOK 800 "   <b>CONGRATULATIONS!</b>\n\n   You're now secureboot off / unlocked!\n\n   Have fun and enjoy your unleashed phone :) !\n\n   <b>Whats next?</b>\n\n   Follow the guide at <a href='https://bit.do/unlockG4'>https://bit.do/unlockG4</a>\n\n   Basic steps are:\n\t- flash TWRP in fastboot\n\t- flash UsU baseband twrp package in TWRP\n\t- flash your custom ROM\n\n   <b><span color='#ff0000'>If you skip flashing the UsU baseband twrp package you will very likely bootloop!</span></b>" '--show-uri'
        $FYAD --title="$YTITLE - Log upload" --width=700 --text "\n\n   Please upload your SALT logfile <b>NOW</b> to ensure important information will not get lost!\n   Click this button and then Upload:\n" \
            --form \
            --field="Upload SALT debug log!$SICONS/log_16x16.png":FBTN "$SALTPATH/getlog" \
            --button=Close
    else
        if [ "$ABAFTER" == "$ABPRE" ];then
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $ABAFTER"
            F_MSGE 800 "   Sorry but flashing seems to be blocked on your device.\n   Nothing has changed! Pls use the one of the other flashing methods."
            F_EXIT $FUNCNAME 2
        else
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $ABAFTER"
            F_MSGE 500 "   This should never happen but if you see this\n   a VERY critical error happened!\n\n   DO NOT POWER OFF YOUR DEVICE!\n\n   Instead use LGup to flash a KDZ otherwise you may hard brick!"
            F_EXIT $FUNCNAME 2
        fi
    fi

}; export -f F_USUFLASH

# flashing UsU extra parts by fastboot (requires UsU already flashed)
F_USUFLFB(){ F_LOG "$FUNCNAME: started with this args: $@"
    # takes 3 args
    #
    # required:
    # 1 => partition to flash
    # 2 => full path to file (without filename)
    # 3 => filename (without path)

    FBP=$1
    FBD="$2"
    FBFN="$3"
    FBF="${FBD}/${FBFN}"

    F_LOG "$FUNCNAME: missing argument:\nFBP=$FBP, FBD=$FBD, FBFN=$FBFN\nFBF=$FBF"
    [ -z "$FBP" -o -z "$FBD" -o -z "$FBFN" ] && F_MSGE 700 "Missing argument" && F_EXIT $FUNCNAME 3
 
    while [ ! -f "$FBF" ];do
        F_LOG "$FUNCNAME: no FBF given >$FBF<"
        FBFA=$($FYAD --image="$SICONS/salt_logo_64x64.png" --width=600 --fixed --title="$YTITLE - FB FLASH" --text="\n    Please tell me the location of the <b><span color='#ff0000'> $FBP </span></b>UsU file\n" \
                     --form --field='    UsU file':FL --file-filter="UsU file ($FBFN)| $FBFN" \
                     --button=Next:0 --button=Abort:99)
        [ "$?" -eq 99 ] && F_EXIT $FUNCNAME 4
        FBF=$(echo "$FBFA" | cut -d "|" -f 1)
    done

    F_LOG "$FUNCNAME: Will flash $FBF to $FBP"
    $FBBIN flash $FBP "$FBF" 2>&1| sed 's/^/#/g'| tee -a $LOG | $FYAD --width=600 --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FB FLASH" --text "\nFlashing $FBP..." --progress --progress-text="...waiting" --pulsate --autoclose --autokill
}; export -f F_USUFLFB

# check LAF protocol version
F_CHKLAFV(){ F_LOG "$FUNCNAME: started with this args: $@"
    # takes 1 arg
    # returns:
    #   no args: detected version | unknown (detect failed)
    #   w arg: 0(ok) | 1(not ok) | unknown (detect failed)
    #
    # optional: 
    # 1 => compare the detection with a max allowed version

    MAXV="$1"
    LAFV=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --proto --rawshell)
    if [ $? -ne 0 ]||[ -z "$LAFV" ]||[ "$LAFV" -lt 1000001 -o "$LAFV" -gt 2000000 ];then
        F_LOG "$FUNCNAME: Unexpected error while retrieving LAF protocol version ($LAFV)"
        echo "unknown"
    else
        F_LOG "$FUNCNAME: detected $LAFV"
        if [ -z "$MAXV" ];then
            F_LOG "$FUNCNAME: no comparison needed"
            echo "$LAFV"
        else
            if [ "$LAFV" -le "$MAXV" ];then
                F_LOG "$FUNCNAME: $LAFV is expected range ($MAXV)"
                echo 0
            else
                F_LOG "$FUNCNAME: $LAFV is higher then expected ($MAXV)"
                echo 1
            fi
        fi
    fi
}; export -f F_CHKLAFV

# Unofficial steadfasterX Unlock
F_DOUSU(){ F_LOG "$FUNCNAME: started with this args: $@"
    # Takes 1 argument
    #
    # 1 => model name

    # kill parent window
    kill -s SIGUSR1 $YAD_PID >> $LOG 2>&1

    # check device connection
    F_CHKDEVCON

    # UsU flashing in SALT will work only up to (including) LAF v4
    RE=$(F_CHKLAFV 1000004)
    if [ "$RE" == "0" ];then
        F_LOG "$FUNCNAME: This laf version is supported!"
    else
        F_MSGE 600 "Oops!\n\nYour Download mode version is not supported!\n\nDowngrade to LP or MM!"
        F_EXIT $FUNCNAME 4
    fi

    # UsU may NOT work with ARB > 2
    ARB=$(F_CDARB)
    DEVARBVAL=$(echo ${ARB}| cut -d ":" -f 1)
    DEVARBEMPT=$(echo ${ARB}| cut -d ":" -f 2)

    if [ $DEVARBEMPT -eq 0 ];then
        DEVARB=$DEVARBVAL
    else
        DEVARB="ARB_unknown"
        F_MSGE 700 "I cannot determine your ARB!\n\nUsU can be flashed only on ARB up to including 2!\n\nABORTED to avoid damage."
        F_EXIT no-arb 3
    fi
    if [ "$DEVARB" -le 2 ];then
        F_LOG "GOOD! Your ARB ($DEVARB) is compatible."
    else
        F_MSGE 700 "UsU can be flashed only on ARB up to including <b>2</b> !\n\nYour ARB is: <b>$DEVARB</b>\n\nABORTED to avoid damage."
        F_EXIT arb-not-allowed 3
    fi

    UMOD=$1
    export LGMODEL=$UMOD

    shopt -s extglob

    case $UMOD in
        ${USUVALIDS}) F_LOG "$FUNCNAME: Valid UsU model found ($UMOD)"
        ;;
        *) F_ELOG "$FUNCNAME: device model $UMOD is not working with this method!"
           F_MSGE 900 "  Your device <b>$UMOD</b> is not supported by this method!\n\n  Supported are:\n\n  $USUVALIDS"
           F_EXIT $FUNCNAME 4
        ;;
    esac
    
    A=$(F_MSGW 900 "  Your device ($UMOD) is supported by UsU!\n\n  This unlock works for any <b>G4</b> model out there but for <b>no other device!</b>\n\n  <b><span color='#ff0000'>Unlocking your device is a risk - always!</span></b>\n\n  You do this on your <b>own</b> risk and without any guarantees\n\n  I do my best to avoid damage but don't cry when this here fails for you.\n  Ensure you have taken at least a basic backup with SALT before proceeding!\n  That backup is your only chance for recovery!" "--button=UNLOCK:99 --fixed")

    F_LOG "$FUNCNAME: Answered: $A"
    if [ "$A" == "99" ];then
        if [ "$LAFVER" == "1000001" ];then
          USUF=$($FYAD --width=800 --title="$YTITLE - UsU" --image="$SICONS/salt_logo_64x64.png" \
            --text="\n   UsU can be installed from either the internal storage, from an external SD card\n   or by flashing directly (your firmware supports this).\n\n   The paths for the UsU file are FIX and <b>can not</b> be changed:\n" \
            --form --columns=2\
            --field='   Placed <b>directly</b> on the sdcard - no subfolder!':LBL true \
            --field='   Placed in <b>/data/media/0/Download</b>':LBL true \
            --field='   Transfer UsU directly from your <b>PC</b>':LBL true \
            --field="UNLOCK by external SDcard":FBTN "bash -c 'F_USUFLASH sdcard'"\
            --field="UNLOCK by /data/media/0/Download":FBTN "bash -c 'F_USUFLASH internal'"\
            --field="UNLOCK by direct flash":FBTN "bash -c 'F_USUFLASH direct'"\
            --button="Cancel":0)
        else
           USUF=$($FYAD --width=800 --title="$YTITLE - UsU" --image="$SICONS/salt_logo_64x64.png" \
            --text="\n   UsU can be installed from either the internal storage or from an external SD card\n   (your firmware does not allow direct flashing)\n\n   The paths for the UsU file are FIX and <b>can not</b> be changed:\n" \
            --form --columns=2\
            --field='   Placed <b>directly</b> on the sdcard - no subfolder!':LBL true \
            --field='   Placed in <b>/data/media/0/Download</b>':LBL true \
            --field="UNLOCK by external SDcard":FBTN "bash -c 'F_USUFLASH sdcard'"\
            --field="UNLOCK by /data/media/0/Download":FBTN "bash -c 'F_USUFLASH internal'"\
            --button="Cancel":0)
        fi

        if [ $? -eq 98 ];then
            USUFL="${USUF/\|/}"
            F_LOG "$FUNCNAME: UsU file selected: $USUFL"
            # check device connection
            F_CHKDEVCON            
        else
            F_LOG "$FUNCNAME: aborted by user"
        fi
    fi

}; export -f F_DOUSU

# new version check
F_VCHK(){ F_LOG "$FUNCNAME: started with this args: $@"
    # Takes no argument
    #
    ONLVF=$($CURLB --connect-timeout 10 --stderr $LOG -s $VCHK | grep "VDIG=" | cut -d "=" -f 2 | tr -d '"')
    ONLV=$(echo "$ONLVF" | tr -d "." | cut -d "-" -f1)
    CURVF=$(echo "$VDIG" | cut -d "=" -f 2 | tr -d '"')
    CURV=$(echo "$CURVF" | tr -d "." | cut -d "-" -f1)

    if [ -z "$ONLV" ]||[ -z "$CURV" ];then
      F_LOG "$FUNCNAME: cannot check for new version:\nonline: $ONLV / $ONLVF\nhere: $CURV / $CURVF"
    else
      if [ $ONLV -gt $CURV ];then
        F_LOG "$FUNCNAME: newer SALT version found ($ONLV / $ONLVF vs. $CURV / $CURVF)"
        UA=$(F_MSGW 700 "New SALT version available!\n\nYou:\t<b>$CURVF</b>\nOnline:\t<b>$ONLVF</b>\n\nDo you want to update now?" "--button=Update:99")
        if [ "$UA" == 99 ];then
            (F_UPDATE)
            F_MSGOK 600 "Will close SALT now due to the update taken!\nJust re-open SALT afterwards."
            F_EXIT "After-Update-End" 0 full 
        fi
      else
        F_LOG "$FUNCNAME: no newer SALT version found ($ONLV / $ONLVF vs. $CURV / $CURVF)"
      fi
    fi
}; export -f F_VCHK

## @fn F_CHKFREE()
## @brief check free disk space for a given folder
## @param 1 the folder / mountpoint to check
## @return free amount of disk space in MB
## @exception when param1 does not exists or can not be opened
F_CHKFREE(){ F_LOG "$FUNCNAME: started with this args: $@"
    CKDIR="$1"
    
    if [ -d "$CKDIR" ];then
        F_LOG "$FUNCNAME: valid dir specificed"
        $DFBIN -m "$CKDIR" | $AWKBIN '{print $4}' | $EGREPBIN "[[:digit:]]"
    else
        F_LOG "$FUNCNAME: The specified directory $CKDIR does not exists"
        echo 0
    fi
    F_LOG "$FUNCNAME: ended."
}; export -f F_CHKFREE

## @fn F_CRRESTART()
## @brief change the CR mode in fix order!
## @param 1 The main SALT window pid (required for killing it)
## @param 2 The mode you currently have: Auto|yes|no
## @exception when param1 does not exists
F_CRRESTART(){ F_LOG "$FUNCNAME: started with this args: $@"
    MAIN_YAD_PID=$1
    CURRENTCR="$2"
    F_LOG "$FUNCNAME: YAD_PID is $MAIN_YAD_PID"
 
    [ -z "$CURRENTCR" -o -z "$MAIN_YAD_PID" ] && F_EXIT "$FUNCNAME: missing parameter CURRENTCR or MAIN_YAD_PID" 0

    case $CURRENTCR in
        Auto)export CRMODE=yes;;
        yes)export CRMODE=no;;
        no)export CRMODE=Auto;;
    esac

    F_LOG "$FUNCNAME: Will change CR from $CURRENTCR to $CRMODE"
    # kill parent windows
    kill -s SIGUSR1 $YAD_PID >> $LOG 2>&1
    kill -s SIGUSR1 $MAIN_YAD_PID >> $LOG 2>&1
    
    F_LOG "$FUNCNAME: Will restart SALT now like that: $FULLCMD"
    $FULLCMD
    F_LOG "$FUNCNAME: ended."
}; export -f F_CRRESTART



